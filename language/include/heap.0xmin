//heap
void #set:(){//documentation
	heap{
		#type int{i29};
		#type Function{
			@(...%[])->%[] & {@};    //non-macro(#) function(->) that takes in a list(...) of register names(%) that store memory addresses([]) and outputs it to a single output register(%) that stores a memory location([]).
			call:#(...%[])->@{};     //property 'call' is a macro function that takes in no arguments
			inputs:#{...%[]};//array of registers
		};
		#type Page{
			next:@Page*;
			last:@Page*;
			isUsed:@bool;
			data:@any[];//+page == +page.data
		};
		malloc:Function(%int length)->%Page*;
		free:Function(%Page*)->void;
		clear:Function(%Page*,%Page*?,%Page*?)->void;
		memset:Function(%Page*,%int16,%int13)->void;
		ref:#(%Page*)->{@};
		unref:#(%Page*,{@}?,!!label?)->{@};
		memory{
			@Page;//start page
			#list of intended actions{
				#def: this;
				$undef: this;
				$def set: this;
			};
		};
	};
};
void #set: 0xmin.settings.language("tptasm");
void #let set: heap{
	#let: free,malloc,clear,memset;//@functions
	#let: ref,unref;
	#let: memory;
	//each of the functions has a '.call(...args)' method
	#let: call;
	#let set: memoryData(){
		#def: malloc;
		#def: free;
		//#def:{
		//	#def: clear;
		//	#def: memset;
		//};
		#def set: memory{
			0x1fffffff;
			#def: page0;
		};
	};
	#;
	#set: call(foo){//call functionName,args
		#let: args={...set arguments;};
		#set: args..splice(0,1);//remove foo
		#let: i=outputSize;
		#let: repeatNum = foo.nextReg.n + (foo.inputs..length-args..length);
		repeat (foo.nextReg.n):{
			@push %i;
			#set: i=i+1;
		};
		{//set inputs
			#let: i=0;
			repeat args..length:{//assume {def a}[0] == {$def a;$set a}
				repeat #(+args[+i]!=+foo.inputs[+i])
					@ %(foo.inputs[+i])=%(args[+i]);
				#set: i=i+1;
			};
		};
		call foo;
		repeat (foo.nextReg.n):{
			#set: i=i-1;
			repeat (+i>=foo.outputs..length):@pop %i;
		};
		#let: startI=0;
		//UNFINNISHED
	}::{
		#let: addCaller(foo,len){
			//repeat (len==1)
			#let: foo.call=2;
			#let: heap_Call=call;
			repeat (len==1)
			#let: foo.call(x){
				...let set: heap_Call(foo,x);
			};
			repeat (len==2)
			#let set: foo.call(x,y){
				...let set: heap_Call(foo,x,y);
			};
			repeat (len==3)
			#let set: foo.call(x,y,z){
				...let set: heap_Call(foo,x,y,z);
			};
		};
	};
	#let: Page()={
		#def let: next{0};//:@* //pointer
		#def let: last{0};//:@* //pointer
		#def let: isUsed{0};
		#def let: data;//:@[] //array
	}::{
		#let: prototype=..this();
		#let: size=prototype..compile..length;
		#let: pointer()={
			...set let prototype;
		};
	};
	//note: Page=().isUsed can used as an int to count refernces for smart pointers.
	#let: page0=Page();//:@
	#set: page0{//start of the heap
		#set: next..splice(0,1,{0x7fff});
		#set: last..splice(0,1,{(page0);});
	};
	#let: enum(start,inputsLen)={
		repeat !inputsLen #set: inputsLen=1;
		#let: newObj={};
		#set: newObj(){
			#set: return =+newObj.n;
			repeat #(newObj.n>=inputsLen):{
				#set: newObj.push{push newObj.n;};
				#set: newObj.pop..splice(0,0,{pop newObj.n;});
			};
			#set: newObj.n=newObj.n+1;
		}::{
			#let: n=start;
			#let: push{};
			#let: pop{};
		};
		#set: return = newObj;
	};
	//
	//%:weak,@:let,$:break,#:this
	#set: malloc{
		#let: nextReg=enum(0);
		#let: inputs{//:#
			#def let: words=nextReg();//:%
		};
		#let: data{
			(page0) #def let: startPage;//:Page*
		};
		#let: outputs{//:#
			#def let: pointer=0;//:%
		};
		...let inputs;
		...let data;
		...let outputs;
		#let: page=nextReg();//:%Page*
		#set: page..splice(0,page..length);
		#set: page{...let set Page();};
		#let: compiledPage=#(page..compile);
		#let: pageSize=nextReg();//:%int
		#let: hasMovedStartPage=nextReg();//:%bool
		#let: remainder=pageSize;
		#let: spaceNeeded=words;
		#let: extraSpace=compiledPage..length;//:int; miminum page size
		%spaceNeeded += extraSpace;
		delete words;
		%page=[startPage];//Page* = [Page**]
		//%page=[%page];//Page = [Page*]
		%hasMovedStartPage=0;
		#let: whenFound;
		#def let: loop{
			#let: failed;
			{//isUsed==0?
				#let: isUsed=pageSize;//:%Page*
				%isUsed=[%page+page.isUsed];
				jump failed if !=0;
			};
			def:{:ifBlock;//moves [startPage] to increase malloc's efficiency
				//assert: %page = next unused page
				%hasMovedStartPage=%hasMovedStartPage;
				jump->ifBlock..return if>0;
				[startPage]=%page;
			};
			{//hasEnoughSpace?
				%pageSize=[%page+page.next];
				%pageSize-=%page;
				%remainder-=%spaceNeeded;
				jump failed if<0;
			};
			jump whenFound;
			#def: failed{
				%page=[%page+page.next];
				jump->loop;
			};
		};
		#def: whenFound{
			[%page+page.isUsed]=1;
			%remainder-=extraSpace;
			jump ..return if<=0;//if no space => dont need to rewire page pointers
			//%remainder+=extraSpace;
			delete remainder;
			//find location for nextPage
			#let: newPage=nextReg();//:%Page*
			#let: nextPage=nextReg();
			%nextPage=[%page+page.next];
			%newPage=%page;
			%newPage+=%spaceNeeded;
			{//setUp page pointers;
				//a<-->c
				//a<->b<->c
				//a=r2,b=r4,c=r5
				#let: a=page,b=newPage,c=nextPage;
				[%b+page.isUsed]=0;
				[%b+page.next]=%c;//b->c
				def:{:block;
					%c-=0x7fff;//if %c == end of heap then don't mutate
					jump->block..return if<=0;//handles end of heap
					[%c+page.last]=%b;//b<-c
				};
				[%b+page.last]=%a;//a<-b aka: b.<- = a
				[%a+page.next]=%b;//a->b aka: a.-> = b
			};
			//setOutput
		};
		%pointer=%page;
		%pointer+=compiledPage..length;
		return;
		#def: data;
	}::{void #set: call.addCaller(..this,1);};
	#set: free{
		#let: nextReg=enum(0);//get next free register
		#let: inputs{//:#
			#def let: pointer=nextReg();//:%Page*
		};
		#let: data{};
		#let: outputs{};
		#let: page=inputs.pointer;//:%Page*
		#set: page..splice(0,page..length);
		#set: page{...let set Page();};
		#let: compiledPage=#(page..compile);
		%page-=compiledPage..length;
		#let otherPage=nextReg();//:%Page* contains next/last page
		#let: isUsed=nextReg();//:bool
		#let: joinIfFree(toOtherPage,toThis){//:#(page property,page property)=> @(%Page*,%Page*)=>void
			//extends low_address_page into high_address_page
			#let: end;
			%otherPage = [%page+toOtherPage];
			%isUsed=[%otherPage+page.isUsed];
			jump->end if!=0;
			//if free then join
			//:delete isUsed
			#let: newAddress=isUsed;//:%Page*
			%newAddress = [%otherPage+toOtherPage];
			[%page+toOtherPage]=%newAddress;//assert: page.toOtherPage=otherPage.toOtherPage
			%newAddress = [%page+toThis];
			[%otherPage+toThis]=%newAddress;//assert: otherPage.toThis=page.toThis
			#def: end;
		};
		#def: joinIfFree(page.next,page.last);
		#def: joinIfFree(page.last,page.next);
		[%page+page.isUsed]=0;
		def:{:moveStartingPage;
			let startPage=isUsed;//:[%]
			///[startPage]=%page if %page<[startPage];
			%startPage=[malloc.data.startPage];
			%startPage-=%page;
			jump->moveStartingPage..return if<=0;
			//assert:%startPage>%page
			[malloc.data.startPage]=%page;
		};
		return;
		#def: data;
	}::{void #set: call.addCaller(..this,1);};
	#set: sizeOf(pageInput){
		#let: lengthOutput=pageInput;
		//%pageInput=%lengthOutput;
		%lengthOutput-=[%page-(Page.prototype..length-Page.prototype.next)];
	};
	#set: clear{//aka fill memory
		#let: nextReg=enum(0);
		#let: self=..this;
		#let: inputs{
			#def let: page=nextReg();//input, page data
		};
		...let inputs;
		delete self;
		#let: data{
			#def let: redHalf{0};
			#def let: blueHalf{0};
		};
		#let offset;
		$offset=>Page.prototype.data;
		#let: address=nextReg();
		%address=%page;
		%page-=offset;
		mask = [data.redHalf];
		#let: fillData=nextReg();
		%fillData=[data.blueHalf];
		#def let: for{
			#let: i=nextReg();
			%i=[%page+Page.prototype.next];
			%i-=%address;
			#let: Loop(n)={
				let end;
				%i-=n;
				jump->end if<0;
				#def let: start;
				{
					let i=0;
					repeat n:{
						[%address+i]=%fillData;
						#i=i+1;
					};
				};
				%address+=n;
				%i-=n;
				jump->start if>0#def end;
				%i+=n;
			};
			#def: Loop(8);
			jump->..return if<=0;
			#def let: loop{
				[%address]=%fillData;
				%address+=1;
				%i-=1;
				jump->..this if>0;
			};
		};
		%page+=offset;
		return;
		#def: data;
	}::{void #set: call.addCaller(..this,1);};
	#set: memset{
		#let: nextReg=enum(0);
		#let: inputs{
			#def let: page=nextReg();//input
			#def let: high=nextReg();
			#def let: low=nextReg();
		};
		...let inputs;
		[clear.data.redHalf]=%high;
		[clear.data.blueHalf]=%low;
		call clear;//clear.call(inputs.page);
		[clear.data.redHalf]=0;
		[clear.data.blueHalf]=0;
		return;
	}::{void #call.addCaller(..this,3);};
	//garbidge collection
		#set: ref(r_address){//#([%Page.data])->{@}
			//can be used when adding a reference
			[%r_address-#(Page.prototype.data-Page.prototype.isUsed)]+=1;
		};
		#set: unref(r_address,deconstruct,longVersion){//:#([%Page.data],{@}?,bool & label?)->{@}
			//can be used when removing a reference
			[%r_address-#(Page.prototype.data-Page.prototype.isUsed)]-=1;
			:block;
			jump->block..return if>0;
			delete block;
			def deconstruct||{};
			repeat 0:{//clear
				%clear.inputs.(0)=%r_address;
				push %r_address;
				%r_address=0xffff;
				[clear.data.redHalf]=%r_address;
				[clear.data.blueHalf]=%r_address;
				pop %r_address;
				call clear;
			};
			#let: nextReg=free.nextReg;
			repeat (+r_address!=+free.inputs[0]):%free.inputs.(0)=%r_address;
			repeat !!longVersion:free.call(r_address);
			repeat !longVersion:call free;
		};
	//----
	#def: memoryData();
};
...let set heap;