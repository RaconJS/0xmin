//15:25
#"0xmin";#"len";
()->{
	let pos{//the 0x2000... is done that way to make converting it to a '\p' easier
		let x=var(0x20000000|8);//:int in range[1,16]
		let y=var( 0x2000000|8);//:int in range[1,12]
		let char=var("\p88");
	};
	let grid{repeat 12:0x1;}¬:>var();
	let snake{
		let len=var(1);
		let maxLen=const(12*16*0+30);
		let pos=pos;
		let direction=var(1);
		//tail side
		0x3fffffff;//used to find the end of the snake.
		def let tail;
		"\p88";
		repeat (maxLen[0]-1):"\p00";
		//head side
	};
	let apple={let x=var(0x100004),y=var(0x100004)};
	let i=-1;
	repeat 3:{def ¬(""...snake[i+=1]);"#"};
	:this;
	#this[-1][-1]=¬"H";
	let heap{
		def snake;
	};
	//the pain begins here. luckilly thanks to get/set jump, the move pointer should not need to leave the var/const area
	move 0xff;
	move=>var;
	let gameEnd{
		"\p00You loose\h";
	};
	def let mainLoop{
		let getInput=getInput({:wait});
		getInput;
		let hitBorder{

		};
		if;//if !!input
		{let then,else;
			jump->then;
			def else{
				jump->then..return;
			};
			def then{
				let setDir=#()={
					let i=-1;
					#this<=>(){
						move=>const(i+=1);get;
						move=>snake.direction;set;
					};
				}();
				def switch()
					<:"w"<:setDir
					<:"a"<:setDir
					<:"s"<:setDir
					<:"d"<:setDir
				;
				move=>else..state.move;
			};
		};
		#let jumpGate1;
		{
			let callList(list,setUp){
				move=>const(0x10);
				red;
				move=>const(+{jump}..compile[0]);
				or;
				set jump+3;
				#setUp=setUp||{null;null};
				setUp;
				let i=-1;
				def let state;
				repeat list..length:{
					let foo=list[i+=1];
					#foo..splice(0,0,{$move=>state..state.move})
					jump->foo;
				};
			};
			let list;
			callList()<:({}::{
				:self;
				#list=self;
				def:{:w;
					move=>snake.pos.y;get;
					decrement();
					move=>snake.pos.y;set;
					if 1;
					move=>const(0x10);
					and;
					move=>gameEnd..state.move;
					if;//if y<0
					jump->gameEnd;
					jump->..return;
				};
				def:{:a;
					move=>snake.pos.x;get;
					decrement();
					move=>snake.pos.x;set;
					if 1;
					move=>const(0x10);
					and;
					move=>gameEnd..state.move;
					if;//if y<0
					jump->gameEnd;
					jump->..return;
				};
				def:{:s;
					move=>snake.pos.y;get;
					increment();
					move=>snake.pos.y;set;
					if 1;
					move=>const(12);
					xor;
					move=>gameEnd..state.move;
					if;//if y!=12
					jump->..return;
					jump->gameEnd;
				};
				def:{:d;
					move=>snake.pos.x;get;
					increment();
					move=>snake.pos.x;set;
					if 1;
					move=>const(0x10);
					xor;
					move=>gameEnd..state.move;
					if;//if x!=16
					jump->..return;
					jump->gameEnd;
				};
				$move=>gameEnd..state.move;
			});
			{:getPosChar;
				move=>pos.y;get;
				move=>const(0x10);red;
				move=>pos.x;or;
				move=>pos.char;set;
			};
			def list;
			delete list;
			def let UpdateScreen{
				move=>snake.tail;get;
				set jump+3;
				jump+2;
				null;
				null;//move curser to head
				" ";
				move=>pos.char;get;
				set jump+3;
				jump+2;
				null;
				null;//move curser to tail
				" ";
			};
			def jumpGate1{
				jump->..return;
				$move=>mainLoop..state.move;
				jump->mainLoop;
				$move=>..state.move;
			};
			let shuffleSnakeParts,growSnake;
			def:{:ifNotTouchApple;
				:if;
				let then,else;
				#then=shuffleSnakeParts;
				#else=growSnake;
				let ifEqual(prop){
					move=>apple[""...prop];get;if;move=>pos[""...prop];
					xor;move=>snake.len;
					if;
					jump->else;
				};
				ifEqual("x");
				ifEqual("y");
				def then;
				move=>else..return..state.move;
				jump->else..return;
				move=>pos.x;
				$move=>snake.len;
				def else;
			};
			#shuffleSnakeParts{
				virtual{//assert: move=>snake.len
					!move=>snake.len;
					jump -1;//ERROR
				};
				{:ifLenGreaterThan1
					get;if 1;
					move=>const(0x10);blue;
					move=>..this..return..state.move;
					if;
				};
				move=>const(0x10);red;//alu == {move=>snake[snake.len]}
				move=>snake-2;
				set jump +3;
				null;
				null;
				null;$move=>0xmin;//assert move=>snake.head-1
				def:{:loop;
					if 1;if 0;0x20000000;
					get jump -1;nor;if;//if not past tail
					jump->loop;
				};
				$move=>snake-1;
			};
			#growSnake{
				virtual{//assert: move=>snake.len
					!move=>snake.len;
					jump -1;//ERROR
				};
				get;
				{:spaghetti1_setHead;
					move=>const(0x10);red;
					move=>const(0x1000);
					let next,setReturner,setReturner.state;
					#def let next.state;
					set jump+3;
					or;//assert alu == {move<=head}
					jump->next;
					{:spaghetti2;
						let moveFromHead,moveToHead;
						$move=>snake+0;
						null#def moveToHead;
						$move=>0xmin;
						set;
						jump->moveFromHead;
						$move=>setReturner.state..state.move;
						set jump+3#def setReturner;
						move=>snake+0;
						jump=>moveToHead;$move=>0xmin;
						null#def moveFromHead;
						$move=>snake+0;
						jump->next..return;
					};
					def next{
						$move=>next.state..state.move;
						move=>pos.char;get;
						#def setReturner.state;
						jump->setReturner;
					};
					$move=>snake+0;
				};
				move=>snake.len;get;
				increment();
				move=>snake.len;set;
			};
		};
		move=>mainLoop..state.move;
		jump->jumpGate1+1;
	};
	def gameEnd;
	def data;
	def heap;
};
...(){
	import lib "var_const.0xmin";
	let Tempory()={//:()=>(#()=>{@}){}
		#this(vars)={
			#set constructor::{
				ram=>..this;
				def vars();
			};
		};
	};
	let tempory=Tempory():>var()[0];
	let indexArray(array,do){
		//$assert: alu = index, do:#()=>{@}
		move=>const({move 1}..compile[0]);red;//$assert: alu:move command
		move=>const({move -0}..compile[0]);
		set jump +3;
		xor;
		move=>array;
		null;//assert: move=>array[index], alu = move<=array[index]
		def do();
		$move=>array;
	};
	let increment(){
		let sub2=const(-2&0x2fffffff);
		tempory()<:()->{
			#def let notIn,notOut;
		};
		#let const_2=const(2);
		move=>notIn;
		set;
		nor;
		set;//notIn= ~input
		blue;
		move=>const_2;
		blue;
		red;
		move=>notOut;
		set;
		nor;
		move=>notIn;
		red;
	};
	let decrement(){
		let sub2=const(-2&0x2fffffff);
		tempory()<:()->{
			#def let val;
			#def let mask;
		};
		move=>val;
		set;
		move=>sub2;
		get;
		move=>val;
		red;
		nor;
		set;
		nor;
		//-x = ~x+1
		//~x = -x-1
		//x+1
	};
	let data{
		jump->..return;
		def var,const;
	};
	let Function()={
		let call(foo){
			jump->foo;
			!jump<-foo..return;
		};
	};
	let getInput(shouldWait){
		//shouldWait:label?
		:this;
		move=>const(0x20000000);get;
		move=>const("\a");
		def let checkBuffer{
			or input;if 1;xor;xor;
			repeat !shouldWait:move=>this..return..state.move;
			{if;//if(no input) then loop or return;
				repeat !shouldWait:jump->this..return;
				repeat !!shouldWait:jump->..this;
			};
		};
		"\a";
		move=>const(0x20000000);
		repeat 13:or_input;
		//if flag is true if there was an input
	};
	let switch(){
		:this;
		let cases{...codeof arguments};//:{...{case:int;code:#(switch,i){@}}[]};
		let cases.case=0,cases.code=1;
		let i=0;
		let lastCase=0;
		if;null;
		repeat (cases..length/2):{//rounded down
			:case;
			let returner={
				move=>this..return..state.move;
				jump->this..return;
				let noTampering;
			};
			let code=cases[i*2+cases.code](case,+i,this);//v,i,a
			move=>const(lastCase^(lastCase=cases[i*2+cases.case]));
			xor;
			repeat !code.noMoveState:move=>returner..return..state.move;
			if;//if value!=case
			jump->returner..return;
			def code;
			#i+=1;
			def returner;
		};
		repeat (i>0 &&!!this[-1].returner.noTampering)#this[-1].returner<=>{};//removes the last jump->..return
	};
};
def .[0]();