#"tptasm";
#"ZASM3";
//attempt at "never nester"
(){//#import lib "static.0xmin";
	let staticFunction(obj,allowRedefine)={//:#(obj) -> obj
		//:(obj:{@},#bool & #({}|(Â¬))) -> obj
		#return = obj;
		repeat (obj..defs..length == 0 || !!allowRedefine)
			#constructor.memory::{def return;};
	};
	...labelsof return = {
		let Static(label)={
			repeat !!label:#this = label;
			staticFunction;
			let this.memory;
		};
		let static = Static=();
	};
}();
...(){//#import lib "R2/regEnum.0xmin"
	let RegEnum(start)={//register enum
		#this<->(start||0);
		(){
			#return = #(arguments[0] || return)<->+..this;
			#..this<->..this + 1;
			repeat (+return > (16-2)):throw "out of registers";
		};
	}::{
		//RegEnum: provides a simple form of register management.
		let ..prototype{
			let push(from,static_regStorage){//staticBlock:({@} on static)?
				//from: #int; number of registers to ignore starting from @r0
				//static_regStorage: {@} on static
				# from = +from || 0;
				let i <-> -1 + from;
				repeat !static_regStorage:
				repeat (this - from): @push r #(+(i+=1));
				repeat !!static_regStorage:{
					let state;
					repeat (this - from):{
						#i = i + 1;
						$state => static_regStorage + i;
						repeat [%static_regStorage + i] = r i;
					}
				};
			};
			let pop(from,static_regStorage){
				let i <-> this;
				repeat !static_regStorage:
				repeat (this - from): @pop r #(+(i-=1));
				repeat !!static_regStorage:{
					let state;
					repeat (this - from):{
						#i = i + 1;
						$state => static_regStorage + i;
						repeat [%static_regStorage + i] = r i;
					}
				};
			};
			let copy(){
				#return = this..constructor(this);
			};
			let blockScope(do,ignore){
				this.push(ignore || ());
				do();
				this.pop(ignore || ());
			};
		};
		let blockScope(regEnum,do,ignore){
			RegEnum(regEnum).push(ignore || ());
			do();//do:#()->{@}
			RegEnum(regEnum).pop(ignore || ());
		};
	};
};
#import lib "heap.0xmin";
undef heap;
let m_for(reps,do){
	let i = -1;
	repeat reps: def do(i = i + 1);
};
let Process(label,isReference)={
	def let startOfStack{0};//:@heap.Object[]* ; -> sp
	def let maxStackSize{0};//:@int
	def let startOfProgram{0};//:@* ; -> ip
	def let registers{repeat 16};//:@int16[14]
	virtual ...codeof labelsof{
		ram => registers + 14;
		def let stackPointer{0};//:@int16 ; current sp
		def let instructionPointer{0};//:@int16 ; current ip
	};
	let stack{
		let start = startOfStack;
		let size = maxStackSize;
		let current = stackPointer;
	};
	let ip = instructionPointer;
	repeat !!isReference let size = ..compile..length;
	repeat !!label #label <=> ..this;
};
let run{
	let reg = regEnum();
	let inputs{
		def let program:>Process=({}):>reg=();//:%Process*
	};
	...labelsof inputs;
	m_for(16)<:(i){
		push r i;
		r i = [r program + #(program.registers + i)];
	};
}:>static();
let interupt{

};
def let main{
};
let interface{
	let bark(){};
	let run(){};
};