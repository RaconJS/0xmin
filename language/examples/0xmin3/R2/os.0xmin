#"tptasm";#"len";
let main;
#main(){
	let terminal;
	call terminal;
	repeat 0 #let kernal{
		let Process(){
			def let registers{repeat 16:0};
		};
		let data{
			def let processes{
				0;//processes:@([]heap & {Process[]})*
			};
			def let currentProcess{
				;
			};
		}:>static();
		let syscall{:onInterupt;

		};
		let runProcess{
			let i = -1;
			repeat {
				#i = i + 1;
				push %i;
			};
		};
	};
	#terminal{
		let reg = RegEnum(0);//:#()->%
		let returnReg = reg();//:%int
		let const_0 = reg();//:% = @0
		let string = reg();//:%([]stack & char[])* ; %(([](stack))*)
		let string.length = reg();
		let regState1 = reg.copy();
		let commandParts = reg()::{
			def let command{0};
			def let arg1{0};
			def let arg2{0};
			#..compile;
		};//:%([]stack & char[])*
		${
			%string = sp;
			%string -= 1;
			%const_0 = #(¬0)::{let is0};
			def let main;
			def let getString{
				let reg = RegEnum(regState1);
				let char = reg();
				${:getInput;
					let loop;
					wait %const_0;
					jump -> getInput if sign;
					bump %const_0;
					def loop;
					recv %char %const_0;
					jump -> loop if !carry;
				};
				send %const_0 %char; 
				%char -= "\r" !store;//return carrage, when 'enter' pressed
				if == 0 jump -> ..return;
				push %char;
				jump -> ..this;
			};
			let restart() = {
				jump -> constructor.block;
			}::{
				let block;
			};
			{//finds string length;
				%string.length = %string;
				%string.length -= sp;
				%string.length += 1;
			};
			{:completeNewLine;
				%string.length & 0xf;
				:ifBlock;
				if == 0 jump -> ifBlock..return;
				send %const_0 "\n";
			};
			%commandParts = sp;
			%commandParts -= 1;
			def let callCommand{
				let reg = RegEnum(regState1);
				let index = reg();
				let commandNumber <-> index;
				let commandType{
					let echo{
						let oldSp;
						sp += 1;
						call [sp - 1];
						sp - [oldSp];
						jump -> ..return if == 0;
						print.number.register({:inputReg}<->0,{:char}<->1,{:const0}<->2,{:i}<->3);
						send r3 "\n";
						sp = [oldSp];
						0 #def oldSp;
					}:>StackFunction():>static();
					let regTypeToStackType{
						push r0;
					}:>StackFunction():>static();
				};
				let commands = {
					#()={
						command:{//consume: all registers
							let commandData:{
								let index:int.ordinal&const;
								let string:string&const;
								let argsLength:int.cardinal&const;
							};
							...({@} & @(pop [argsLength]) -> void & mutate terminal,heap)
						};
					};
					repeat 0 let regs = {
						let arg1 = reg();
						let arg2 = reg();
					};
					let read{
						let commandData{
							let argsLength = 1;
							let returnsVal = {};
						};
						%returnReg = [%commandParts - commandParts.arg1];
					};
					let write{
						let commandData{
							let argsLength = 2;
							let returnsVal = ¬;
						};
						...labelsof regs;
						push = [%commandParts - commandParts.arg2];
						[%commandParts - commandParts.arg1] = pop;

					};
					let run{
						let commandData{
							let argsLength = 2;
							let returnsVal = {};
						};
						...labelsof regs;
						let storeRegs = {
							repeat +reg 0;
						}:>static();
						{
							//assume: returnReg == r0
							reg.push(1,storeRegs);//does not push returnReg, to allow returning values
							{
								let store{
									let sp = {0}:>static();
									let program = {0}:>static();
								};
								[store.sp] = sp;
								{
									%returnReg = [%commandParts - commandParts.arg2];
									let temp = commandParts;
									%temp = [%commandParts - commandParts.arg1];let commandParts = ¬;
									[store.program] = temp;
									{:zeroAllRegisters;
										let i = #(returnReg + 1);
										repeat 14:{
											%i = 0;
											#i += 1;
										};
									};
									call [store.program];
								};
								sp = [store.sp];
							};
							reg.pop(1,storeRegs);
						}
					};
					let malloc{
						let commandData{
							let argsLength = 2;
							let returnsVal = {};
						};
						r0 = [%commandParts - commandParts.arg1];
						call heap.malloc;
					};
					let help{
						nop;//help
						print(
							"cmd int16 int16\n"...
							"All numbers are\n"...
							"in hex.\n"...
							"read, write, run"...
							", malloc."
						);
					}
					delete regs;
				}::{
					let endCommand;
					let echoResult = static()<:{
						:echo;
						print.number.register(returnReg);
						jump -> callCommand..return;
					};
					#:{
						let i = -1;
						repeat ..labels..length #:{#;
							let name = ..labels[i+=1];
							let label = ..this[name];
							let label.commandData.index = +i;
							let label.commandData.string = ""...name;
							#label..splice(0,0,{
								repeat !!label.commandData.returnsVal:	jump -> echoResult;
								repeat !label.commandData.returnsVal: jump -> callCommand..return;
							});
						};
					};
				};
				let match(stringObj,startIndex,do){
					:matchObj;
					let i = -1;
					repeat stringObj..length {
						#i += 1;
						repeat !!startIndex: %index = #(startIndex + i);
						[%string - %index] - stringObj.(i);//using 'oper [REG + REG] U11' instead of 'oper [REG + U11] U4'
						if != 0 jump -> matchObj..return;
					};
					def do;
					jump -> match.then;
					#i += 1;
				}::{
					let then;
				};
				let match.checkLength(length,do){
					%string.length - length;
					jump-> do..return if < 0;
					def do;
				};
				let onInvalidCommand;
				{:matchCommand;
					#match.then = matchCommand..return;
					print.number(string.length);
					match.checkLength(3)<:{
						match("r",0)<:{
							match("un",1)<:{
								push commands.run:>static();
							};
							match.checkLength(4)<:
							match("ead",1)<:{
								push commands.read:>static();
							};
						};
						match.checkLength(5)<:
						match("write",0)<:{
							push commands.run:>static();
						};
						match.checkLength(4)<:
						match("help",0)<:{
							let next;
							let oldThen = match.then;
							push commands.help:>static();
						};
					};
					def onInvalidCommand{
						:noMatchesFound;
						print("invalid command\n",const_0);
						restart();
					};
				};
				let matchArgument{
					let stringIndex = index;
					//assert %stringIndex == (command string).length
					${:skipSpaces;
						{:checkProperCommand;
							%string.length - %stringIndex;
							:block;
							jump -> restart.block if < 0;
							jump -> block..return if > 0;
							//assert: %string.length == %stringIndex
							push 0;//no arguments provided
							return;
							[%string - %stringIndex] - " ";
							jump -> onInvalidCommand if != 0;
						};
						//allows for multiple spaces between arguments
						${:loop;
							[%string - %stringIndex] - " ";
							jump -> loop..return if != 0;
							%stringIndex += 1;
							jump -> loop;
						};
					};
					{:matchNumber;
						let reg = RegEnum(regState1);
						let matchHex1{
							[%string - %stringIndex] - "f";
							if > 0 jump -> throw;
							[%string - %stringIndex] - "A";
							let: throw{
								print(
									"invalid number:\n"...
									"got:'",const_0
								);
								print.char()
									"only: 0-9 a-f A-F"...
									"are valid."
								,const_0);
							};
						};
					};
					return;
				};
				repeat 2 call matchArgument:>static();
				RegEnum.blockScope(reg)<:(){:TEST;
					print("calling");
					r0 = [%commandParts - commandParts.command];
					print.number(0);
				};
				call [%commandParts - commandParts.command];
			};
			def restart.block{
				sp = %string;
				sp += 1;
				//send %const_0 "\p00";
				jump -> main;
			};
		};
	}:>static();
};
...(){
	//import lib "heap.0xmin";
	//import lib "R2/class.0xmin";
	import lib "R2/print.0xmin";//print
	let Static(label)={
		repeat !!label:#this = label;
		#this::(obj,redefine)={//:(obj:{@},#bool & (#{}|(¬))) -> obj
			#return = obj;
			repeat (obj..defs..length == 0 || !!allowDuplicates)
				#constructor.memory::{def return;};
		};
		let this.memory;
	};
	let static = Static=();
	let readHigh(rOut,rAddress){
		@(0x11100001 | (rOut & 0xf << 8) | (rAddress & 0xf << 4));
	};
	let RegEnum(start)={//register enum
		#this<->(start||0);
		(){
			#return = #(arguments[0] || return)<->+..this;
			#..this<->..this + 1;
			repeat (+return > (16-2)):throw "out of registers";
		};
	}::{
		//RegEnum: provides a simple form of register management.
		let ..prototype{
			let push(from,static_regStorage){//staticBlock:({@} on static)?
				//from: #int; number of registers to ignore starting from @r0
				//static_regStorage: {@} on static
				# from = +from || 0;
				let i <-> -1 + from;
				repeat !static_regStorage:
				repeat (this - from): @push r #(+(i+=1));
				repeat !!static_regStorage:{
					let state;
					repeat (this - from):{
						#i = i + 1;
						$state => static_regStorage + i;
						repeat [%static_regStorage + i] = r i;
					}
				};
			};
			let pop(from,static_regStorage){
				let i <-> this;
				repeat !static_regStorage:
				repeat (this - from): @pop r #(+(i-=1));
				repeat !!static_regStorage:{
					let state;
					repeat (this - from):{
						#i = i + 1;
						$state => static_regStorage + i;
						repeat [%static_regStorage + i] = r i;
					}
				};
			};
			let copy(){
				#return = this..constructor(this);
			};
		};
		let blockScope(regEnum,do){
			RegEnum(regEnum).push();
			do();//do:#()->{@}
			RegEnum(regEnum).pop();
		};
	};
	let StackFunction(function)={//function: @(pop []) -> push []
		#return = function;
		let returnValue;//:[@] == @*
		#function..splice(0,0,{
			[returnValue] = pop;
		});
		#function..splice(-0,0,{
			jump -> [returnValue];
			@ 0 #def returnValue;//TEST
		});
	};
};
let fullProgram(){
	def main();
	//def heap.malloc;
	//def heap.free;
	//def heap.realloc;
	def static.memory;
	//def heap.memory;
};
fullProgram();