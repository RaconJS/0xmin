#"tptasm";#"len";
let main;
#main(){
	let terminal;
	call terminal;
	#terminal{
		let reg = RegEnum(0);//:#()->%
		let returnReg = reg();//:%int
		let const_0 = reg();//:% = @0
		let string = reg();//:%([]stack & char[])* ; %(([](stack))*)
		let string.length = reg();
		let commandParts = reg()::{
			def let command{0};
			def let arg1{0};
			def let arg2{0};
			#..compile;
		};//:%([]stack & char[])*
		let regState1 = reg.copy();
		${
			%string = sp;
			%string += 1;
			%const_0 = 0;
			def let getString{
				let reg = RegEnum(regState1);
				let char = reg();
				${:getInput;
					let loop;
					wait %const_0;
					jump -> getInput if sign;
					bump %const_0;
					def loop;
					recv %char %const_0;
					jump -> loop if !carry;
				};
				send %const_0 %char; 
				%char -= "\r" !store;//return
				if == 0 jump -> ..return;
				push %char;
				jump -> ..this;
			};
			{//finds string length;
				%string.length = sp;
				%string.length -= %string;
			};
			{:completeNewLine;
				%string.length & 0xf;
				:ifBlock;
				if == 0 jump -> ifBlock..return;
				send %const_0 "\n";
			};
			%commandParts = sp;
			def let callCommand{
				let reg = RegEnum(regState1);
				let index = reg();
				let commandNumber <-> index;
				let commandType{
					let echo{
						let oldSp;
						sp += 1;
						call [sp - 1];
						sp - [oldSp];
						jump -> ..return if == 0;
						print.number.register({:inputReg}<->0,{:char}<->1,{:const0}<->2,{:i}<->3);
						send r3 "\n";
						sp = [oldSp];
						0 #def oldSp;
					}:>StackFunction():>static();
					let regTypeToStackType{
						push r0;
					}:>StackFunction():>static();
				};
				let commands = {
					#()={
						command:{//consume: all registers
							let commandData:{
								let index:int.ordinal&const;
								let string:string&const;
								let argsLength:int.cardinal&const;
							};
							...({@} & @(pop [argsLength]) -> void & mutate terminal,heap)
						};
					};
					let regs = {
						let reg = RegEnum(0);
						let arg1 = reg();
						let arg2 = reg();
					};
					let read{
						let commandData{
							let argsLength = 1;
						};
						...labelsof regs;
						%arg1 = pop;
						push [%arg1];
					};
					let write{
						let commandData{
							let argsLength = 2;
						};
						...labelsof regs;
						%arg1 = pop;
						%arg2 = pop;
						push [%arg1];
					};
					let run{
						let commandData{
							let argsLength = 1;
						};
						...labelsof regs;
						sp += 1;
						RegEnum(14).push();
						push sp;
						call [sp - 1];
						pop sp;
						RegEnum(14).pop();
					};
					let malloc{
						let commandData{
							let argsLength = 1;
						};
						...labelsof regs;
						r0 = pop;
						call heap.malloc;
						push r0;
					};
					delete regs;
				}::{
					{
						let i = -1;
						repeat ..labels..length {
							let name = ..labels[i+=1];
							let label = ..this[name];
							let label.commandData.index = +i;
							let label.commandData.string = ""...name;
							label:>StackFunction();
						};
					};
				};
				commands..compile;
				{:matchCommand;
					let match(stringObj,startIndex,do){
						:matchObj;
						let i = -1;
						repeat stringObj..length {
							%index = #(startIndex + (i+=1));
							[%string + %index] - stringObj.(i);//using 'oper [REG + REG] U11' instead of 'oper [REG + U11] U4'
							if != 0 jump -> matchObj..return;
						};
						def do;
						#i += 1;
					};
					match("r",0)<:{
						match("ead",1)<:{
							push commands.read:>static();
							jump -> matchCommand..return;
						};
						match("un",1)<:{
							push commands.run:>static();
							jump -> matchCommand..return;
						};
					};
					match("write",0)<:{
						push commands.run:>static();
					};
				};
				let matchArgument{
					let stringIndex = index;
					//assert %stringIndex == (command string).length
					
				};
				repeat 2 call matchArgument:>static();
			};
			sp = %string;
			//send %const_0 "\p00";
			:main;
			jump -> main;
		};
	}:>static();
};
...(){
	//import lib "heap.0xmin";
	//import lib "R2/class.0xmin";
	let Static(label)={
		repeat !!label:#this = label;
		#this::(obj,redefine)={//:(obj:{@},#bool & (#{}|(Â¬))) -> obj
			#return = obj;
			repeat (obj..defs..length == 0 || !!allowDuplicates)
				#constructor.memory::{def return;};
		};
		let this.memory;
	};
	let static = Static=();
	let readHigh(rOut,rAddress){
		@(0x11100001 | (rOut & 0xf << 8) | (rAddress & 0xf << 4));
	};
	let print(str,const_0){
		#const_0 = const_0 || 1;
		r const_0 = 0;
		let i = -1;
		repeat str..length{
			send r const_0 str.(i += 1);
		};
	}::{
		let number{
			let charSet = "0123456789ABCDEF";
			let register(regInput,reg_char,reg_const_0,reg_i){
				#reg_const_0 = reg_const_0 || 1;
				r reg_const_0 = 0;
				#let temp = regInput;
				repeat !!reg_i:{
					r reg_i = 4;
				};
				def let loop;
				repeat {4;1}[!!reg_i] {
					r reg_char = 0;
					r temp <<<= 4;//circular shift
					r reg_char <<= 4 + internal;
					send r reg_const_0 r reg_char;
				};
				repeat !!reg_i:{
					r reg_i -= 1;
					jump -> loop if >= 0;
				};
			};
			let hexChar(regInt,reg_char,const_0){
				#const_0 = const_0 || 1;
				r char = 0;
				r temp <<<= 4;//circular shift
				r char <<= 4 + internal;

				send r const_0 [print.number.charSet:>static() + r char];
			};
		};
	};
	let RegEnum(start)={//register enum
		#this<->(start||0);
		(){
			#return = #(arguments[0] || return)<->+..this;
			#..this<->..this + 1;
			repeat (+return > (16-2)):throw "out of registers";
		};
	}::{
		//RegEnum: provides a simple form of register management.
		let ..prototype{
			let push(){
				let i = -1;
				repeat +this: @push r #(+(i+=1));
			};
			let pop(){
				let i = this + 1;
				repeat +this: @pop r #(+(i-=1));
			};
			let copy(){
				#return = this..constructor(this);
			};
		}
	};
	let StackFunction(function)={//function: @(pop []) -> push []
		#return = function;
		let returnValue;//:[@] == @*
		#function..splice(0,0,{
			[returnValue] = pop;
		});
		#function..splice(-0,0,{
			jump -> [returnValue];
			@ 0 #def returnValue;
		});
	};
};
let fullProgram(){
	def main();
	//def heap.malloc;
	//def heap.free;
	//def heap.realloc;
	def static.memory;
	//def heap.memory;
};
fullProgram();