#"tptasm";#"len";
let main;
#main(){
	let terminal;
	call terminal;
	let osIsActive{0};
	let IO{
		def let cursorPos{0};//define when used
	};
	let reset_OS_state{//@() -> mutations
		def let clearScreen{
			{:forLoop;
				let reg = RegEnum();
				let const_0 = reg();
				let i = reg();
				reg.blockScope()<:(){
					%i = #(16*12);
					def let loop;
					print({" "})
					%i -= 1;
					jump -> loop if >= 0;
				};
			};
		};
		def let resetTerminal{
			let const_0 = 1;
			push %const_0;
			%const_0 = 0;
			send %const_0 "\c00";
			bump %const_0;
			pop %const_0;
			delete const_0;
		};
		def let reset{
			sp = 0xffff;
			[IO.cursorPos] = 0;
			[osIsActive] = 0;
		};
		return;
	};
	repeat 0 #let kernal{
		...labelsof {:types;
			let Process()={
				def let registers{repeat 16:0};
			}::{
				let ..prototype.run(){
					let i = -1;
					let state;
					repeat 16:{
						#i = i + 1;
						$state => this + i;
						%i = [state];
					};
				};
				let ..prototype.save(){
					let i = -1;
					let state;
					$state => this + 15;//ip
					[state] = pop;
					repeat 15:{
						#i = i + 1;
						$state => this + i;
						[state] = %i;
					};
				};
				let ..prototype.copyFrom(){
					;//UNFINISHED
				};
				let ..prototype.size = 16;
			};
			let Ref(contence)={//Ref<T>:@T*
				0;
				let contence = contence;
			};
			let Array(contence){//Array<T>:@T[]
				let contence = contence;
			};
		};
		let data{
			def let processes{} <=> Ref()<:Array()<:Process=();//processes:@([]heap & @Process[])*
			def let currentProcess{} <=> Process=();
		}:>static();
		let syscall{:onInterupt;
			;
		};
		let runProcess{
			let i = -1;
			repeat {
				#i = i + 1;
				push %i;
			};
		};
	};
	#let shell{//@(len:%int,string:%char[len]*,%@(%{length:int;char[length]}*)->{}*)->void, consumes all registers
		let reg = RegEnum();
		let inputs{
			let string <-> reg();//:mut %char[length]*
			let string{
				let length <-> reg();//:mut %int
			};
			let throw <-> reg();
		};
		let returnString(){
			inputs.throw();
		};
		let match(stringObj,startIndex,do){
			:matchObj;
			let i = -1;
			repeat stringObj..length {
				#i += 1;
				repeat !!startIndex: %index = #(startIndex + i);
				[%string + #(startIndex||0 + i)] - stringObj.(i);//using 'oper [REG + REG] U11' instead of 'oper [REG + U11] U4'
				if != 0 jump -> matchObj..return;
			};
			def do;
			jump -> match.then;
			#i += 1;
		}::{
			let then;
		};
		let match.checkLength(length,do){
			%string.length - length;
			jump-> do..return if < 0;
			def do;
		};
		let onInvalidCommand;
		{:matchCommand;
			#match.then = matchCommand..return;
			match.checkLength(3)<:{
				match("r",0)<:{
					match("un",1)<:{
						push commands.run:>static();
						%string += 
						
					};
					match.checkLength(4)<:
					match("ead",1)<:{
						push commands.read:>static();
					};
				};
				match.checkLength(5)<:
				match("write",0)<:{
					push commands.run:>static();
				};
				match.checkLength(4)<:
				match("help",0)<:{
					let next;
					let oldThen = match.then;
					push commands.help:>static();
				};
			};
			def onInvalidCommand{
				:noMatchesFound;
				print("invalid command\n");
				restart();
			};
		};
		{

			let matchArgument{
				let stringIndex = index;
				//assume: %stringIndex == (index of last element in (command | number) word) + 1.
				${:skipSpaces;
					{:checkProperCommand;
						let checkSpaceOrSymbol;
						{:lengthCheck;
							%string.length - %stringIndex;
							:block;
							jump -> block..return if > 0;
							//assert: %string.length == %stringIndex
							//assert: no argument provided
							push 0;
							jump -> matchArgument..return;
						};
						def checkSpaceOrSymbol{
							let success;
							[%string - %stringIndex] - " ";
							jump -> success if == 0;
							{:fail;
								jump -> onInvalidCommand;
							};
							#def success{
								%stringIndex += 1;
							};
						};
					};
					${:loop;
						//allows for multiple spaces between arguments
						[%string - %stringIndex] - " ";
						jump -> loop..return if != 0;
						%stringIndex += 1;
						jump -> loop;
					};
				};
				//assert [%string - %stringIndex]:(char & hex character)?
				${:matchNumber;
					let reg = RegEnum(regState2);
					let value{
						let char <-> reg();
						let int4 = reg();
						let int16 = reg();
						let i = reg();
					};
					...labelsof value;
					let foundValue, invalidValue;
					let matchGroup(low,high){
						%char - high;
						if > 0 jump -> invalidValue;
						%int4 = %char;
						%int4 -= low;
						if >= 0 jump -> foundValue;
						//assert %char < low
					};
					%i = 4;
					%int16 = 0;
					def let loop{
						let break;
						%string.length - %stringIndex;
						jump -> break if <= 0;
						%char = [%string - %stringIndex];
						matchGroup(+"a",+"f");
						matchGroup(+"A",+"F");
						matchGroup(+"0",+"9");
						def invalidValue{
							%const_0 = 0;
							print(
								"invalid number:\n"...
								"got:'"
							,const_0,{});
							print.char(char,const_0,{});
							print(
								"'\n"...
								"only: 0-9 a-f A-F"...
								"are valid."
							,const_0,{});
							restart();
						}:>static();
						delete char;
						def foundValue{
							%int16 <<= 4;
							%int16 |= %int4;
						};
					};
					%stringIndex += 1;
					%i -= 1;
					jump -> loop if >= 0;
					def loop.break;
					push %int16;
				};
			};
			%index += 1;
			let i <-> const_0;
			%i = 2;
			def matchArgument;
			%i -= 1;
			jump -> matchArgument if > 0;
		};
	};
	def let testFunction1{
		nop;//print function
		print("???");
		r0 = 0x1234;
		return;
	};
	def let testFunction2{
		nop;//print function
		print("hello world");
		return;
	};
	#terminal{
		let reg = RegEnum(0);//:#()->%
		let string = reg();//:%([]stack & char[])* ; %(([](stack))*)
		let const_0 = reg();//:% = @0
		let cursorPos = reg()::{
			let store = IO.cursorPos;
		};
		let string.length = reg();
		let regState1 = reg.copy();
		${
			%string = sp;
			%string -= 1;
			%const_0 = #(¬0)::{let is0};
			def let main;
			repeat 1 def let getString{
				let reg = RegEnum(regState1);
				let char = reg();
				${:getInput;
					let loop;
					wait %const_0;
					jump -> getInput if sign;
					bump %const_0;
					def loop;
					recv %char %const_0;
					jump -> loop if !carry;
				};
				send %const_0 %char; 
				%char -= "\r" !store;//return carrage, when 'enter' pressed
				if == 0 jump -> ..return;
				push %char;
				jump -> ..this;
			};
			repeat 0 {:TEST;
				push "r";
				push "e";
				push "a";
				push "d";
				push " ";
				push "f";
				print("read f");
			};
			let restart() = {
				jump -> constructor.block;
			}::{
				let block;
			};
			{//finds string length;
				%string.length = %string;
				%string.length -= sp;
				%string.length += 1;
			};
			{:completeNewLine;
				%string.length & 0xf;
				:ifBlock;
				if == 0 jump -> ifBlock..return;
				send %const_0 "\n";
			};
			let callCommand{//:@(string:%@[length]*,%length) -> mutate terminal, r0:int
				let reg = RegEnum(regState1);
				let returnReg{
					$¬0;//:%int
					$¬1;//:%int
				} <-> 0;
				repeat (+string!=0) throw "assersion failed";
				repeat (+returnReg[1]!=1) throw "assersion failed";
				let const_0 = reg();//:% = @0
				let index = reg();//string index
				let commandParts = reg()::{
					def let command{0};
					def let arg1{0};
					def let arg2{0};
					#..compile;
				};//:%([]stack & char[])*
				let regState2 = reg.copy();
				let string.i = index;
				let commands = {
					#()={
						command:{//consume: all registers
							let commandData:{
								let index:int.ordinal&const;
								let string:string&const;
								let argsLength:int.cardinal&const;
							};
							...({@} & @(pop [argsLength]) -> void & mutate terminal,heap)
						};
					};
					repeat 0 let regs = {
						let arg1 = reg();
						let arg2 = reg();
					};
					let read{
						//0123456789abcdef
						//write 1234 1234
						let commandData{
							let argsLength = 1;
							let returnsVal = {};
						};
						let memoryLocation <-> returnReg.(0);
						%memoryLocation = %commandParts;
						%memoryLocation -= commandParts.arg1;
						%returnReg.(0) = [%commandParts - commandParts.arg1];
						readHigh(returnReg[1],memoryLocation);
					};
					let write{
						let commandData{
							let argsLength = 2;
							let returnsVal = ¬;
						};
						...labelsof regs;
						push = [%commandParts - commandParts.arg2];
						[%commandParts - commandParts.arg1] = pop;

					};
					let run{
						let commandData{
							let argsLength = 2;
							let returnsVal = {};
						};
						...labelsof regs;
						let storeRegs = {
							repeat +(reg-1) 0;
						}:>static();
						{
							//assume: returnReg == r0
							reg.push(1,storeRegs);//does not push returnReg, to allow returning values
							{
								let store{
									let sp = {0};
									let program = {0};
								};
								[store.sp:>static()] = sp;
								{
									%returnReg = [%commandParts - commandParts.arg2];
									let temp = commandParts;
									%temp = [%commandParts - commandParts.arg1];let commandParts = ¬;
									[store.program:>static()] = %temp;
									{:zeroAllRegisters;
										let i = 0;
										repeat 15:{
											%i = 0;
											#i = i + 1;
										};
									};
									call [store.program];
								};
								sp = [store.sp];
							};
							reg.pop(1,storeRegs);
						};
					};
					let malloc{
						let commandData{
							let argsLength = 2;
							let returnsVal = {};
						};
						r0 = [%commandParts - commandParts.arg1];
						call heap.malloc;
					};
					let help{
						nop;//help
						print("help");//TEST
						repeat 0 print(//!TEST
							"cmd int16 int16\n"...
							"All numbers are\n"...
							"in hex.\n"...
							"read, write, run"...
							", malloc."
						);
					}
					delete regs;
				}::{
					let endCommand;
					let echoResult = static()<:{
						:echo;
						let next;
						%returnReg.(1) | 0;
						jump -> next if == 0;
						print.number.register(returnReg[1]);
						def next;
						delete next;
						print.number.register(returnReg[0]);
						jump -> callCommand..return;
					};
					#:{
						let i = -1;
						repeat (¬..labels)..length #:{#;
							let name = #(¬..labels)[i+=1];
							let label = ..this[""...name];
							let label.commandData.index = +i;
							let label.commandData.string = ""...name;
							#label..splice(-0,0,{
								repeat !!label.commandData.returnsVal:	jump -> echoResult;
								repeat !label.commandData.returnsVal: jump -> callCommand..return;
							});
						};
					};
				};
				let match(stringObj,startIndex,do){
					:matchObj;
					let i = -1;
					repeat stringObj..length {
						#i += 1;
						repeat !!startIndex: %index = #(startIndex + i);
						[%string - %index] - stringObj.(i);//using 'oper [REG + REG] U11' instead of 'oper [REG + U11] U4'
						if != 0 jump -> matchObj..return;
					};
					def do;
					jump -> match.then;
					#i += 1;
				}::{
					let then;
				};
				let match.checkLength(length,do){
					%string.length - length;
					jump-> do..return if < 0;
					def do;
				};
				let onInvalidCommand;
				%commandParts = sp;
				%commandParts -= 1;
				{:matchCommand;
					#match.then = matchCommand..return;
					match.checkLength(3)<:{
						match("r",0)<:{
							match("un",1)<:{
								push commands.run:>static();
							};
							match.checkLength(4)<:
							match("ead",1)<:{
								push commands.read:>static();
							};
						};
						match.checkLength(5)<:
						match("write",0)<:{
							push commands.run:>static();
						};
						match.checkLength(4)<:
						match("help",0)<:{
							let next;
							let oldThen = match.then;
							push commands.help:>static();
						};
					};
					def onInvalidCommand{
						:noMatchesFound;
						print("invalid command\n");
						restart();
					};
				};
				{

					let matchArgument{
						let stringIndex = index;
						//assume: %stringIndex == (index of last element in (command | number) word) + 1.
						${:skipSpaces;
							{:checkProperCommand;
								let checkSpaceOrSymbol;
								{:lengthCheck;
									%string.length - %stringIndex;
									:block;
									jump -> block..return if > 0;
									//assert: %string.length == %stringIndex
									//assert: no argument provided
									push 0;
									jump -> matchArgument..return;
								};
								def checkSpaceOrSymbol{
									let success;
									[%string - %stringIndex] - " ";
									jump -> success if == 0;
									{:fail;
										jump -> onInvalidCommand;
									};
									#def success{
										%stringIndex += 1;
									};
								};
							};
							${:loop;
								//allows for multiple spaces between arguments
								[%string - %stringIndex] - " ";
								jump -> loop..return if != 0;
								%stringIndex += 1;
								jump -> loop;
							};
						};
						//assert [%string - %stringIndex]:(char & hex character)?
						${:matchNumber;
							let reg = RegEnum(regState2);
							let value{
								let char <-> reg();
								let int4 = reg();
								let int16 = reg();
								let i = reg();
							};
							...labelsof value;
							let foundValue, invalidValue;
							let matchGroup(low,high){
								%char - high;
								if > 0 jump -> invalidValue;
								%int4 = %char;
								%int4 -= low;
								if >= 0 jump -> foundValue;
								//assert %char < low
							};
							%i = 4;
							%int16 = 0;
							def let loop{
								let break;
								%string.length - %stringIndex;
								jump -> break if <= 0;
								%char = [%string - %stringIndex];
								matchGroup(+"a",+"f");
								matchGroup(+"A",+"F");
								matchGroup(+"0",+"9");
								def invalidValue{
									%const_0 = 0;
									print(
										"invalid number:\n"...
										"got:'"
									,const_0,{});
									print.char(char,const_0,{});
									print(
										"'\n"...
										"only: 0-9 a-f A-F"...
										"are valid."
									,const_0,{});
									restart();
								}:>static();
								delete char;
								def foundValue{
									%int16 <<= 4;
									%int16 |= %int4;
								};
							};
							%stringIndex += 1;
							%i -= 1;
							jump -> loop if >= 0;
							def loop.break;
							push %int16;
						};
					};
					%index += 1;
					let i <-> const_0;
					%i = 2;
					def matchArgument;
					%i -= 1;
					jump -> matchArgument if > 0;
				};
				repeat 0 {:TEST;
					sp-=4;
					RegEnum.blockScope(1)<:(){
						print("calling\n");
						repeat 1 {
							r0 = [%commandParts - commandParts.command];
							print.number(0);
							print("\n");
							r0 = [%commandParts - commandParts.arg1];
							print.number(0);
							print("\n");
							r0 = [%commandParts - commandParts.arg2];
							print.number(0);
							print("\n");
						};
					};
					sp+=4;
				};
				jump -> [%commandParts - commandParts.command];
			};
			def callCommand;
			def restart.block{
				sp = %string;
				sp += 1;
				//send %const_0 "\p00";
				jump -> main;
			};
		};
	}:>static();
};
...labelsof{
	//import lib "heap.0xmin";
	//import lib "R2/class.0xmin";
	import lib "R2/print.0xmin";//print
	let Static(label)={
		repeat !!label:#this = label;
		#this::(obj,allowRedefine)={//:(obj:{@},#bool & #({}|(¬))) -> obj
			#return = obj;
			repeat (obj..defs..length == 0 || !!allowRedefine)
				#constructor.memory::{def return;};
		};
		let this.memory;
	};
	let static = Static=();
	let readHigh(rOut,rAddress){
		@(0x11100001 | (rOut & 0xf << 8) | (rAddress & 0xf << 4));
	};
	let RegEnum(start)={//register enum
		#this<->(start||0);
		(){
			#return = #(arguments[0] || return)<->+..this;
			#..this<->..this + 1;
			repeat (+return > (16-2)):throw "out of registers";
		};
	}::{
		//RegEnum: provides a simple form of register management.
		let ..prototype{
			let push(from,static_regStorage){//staticBlock:({@} on static)?
				//from: #int; number of registers to ignore starting from @r0
				//static_regStorage: {@} on static
				# from = +from || 0;
				let i <-> -1 + from;
				repeat !static_regStorage:
				repeat (this - from): @push r #(+(i+=1));
				repeat !!static_regStorage:{
					let state;
					repeat (this - from):{
						#i = i + 1;
						$state => static_regStorage + i;
						repeat [%static_regStorage + i] = r i;
					}
				};
			};
			let pop(from,static_regStorage){
				let i <-> this;
				repeat !static_regStorage:
				repeat (this - from): @pop r #(+(i-=1));
				repeat !!static_regStorage:{
					let state;
					repeat (this - from):{
						#i = i + 1;
						$state => static_regStorage + i;
						repeat [%static_regStorage + i] = r i;
					}
				};
			};
			let copy(){
				#return = this..constructor(this);
			};
			let blockScope(do,ignore){
				this.push(ignore || ());
				do();
				this.pop(ignore || ());
			};
		};
		let blockScope(regEnum,do,ignore){
			RegEnum(regEnum).push(ignore || ());
			do();//do:#()->{@}
			RegEnum(regEnum).pop(ignore || ());
		};
	};
	let unimplemented(){
		throw;
	};
	let assert(bool){
		repeat !bool throw;
	};
};
let fullProgram(){
	def main();
	//def heap.malloc;
	//def heap.free;
	//def heap.realloc;
	def static.memory;
	//def heap.memory;
};
fullProgram();