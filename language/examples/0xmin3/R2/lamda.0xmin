#"tptasm";#"len";#"table";
let lamda(){//01010011
	(t>f>
		(and>or>nor>
			and f f (a>p n) (a>p p n) n
		)
		(a>b>a b f)//and
		(a>b>a t b)//or
		(a>b>a f (b f t))//nor
	)
	(a>b>a)
	(a>b>b)
	//(a>b>(f>x>a f (b f x)))//+
	//(a>b>(f>x>a (x>b f x) x))//*
	//(f>x>f(f x))//2
	//(f>x>f(f(f x)))//3
}::{//p = print
	let val{"0"};
	def let .["p"] {r0=0;send r0 [val];return;#def val};
	def let .["<<"] {[val]<<=1;return};
	def let .[">>"] {[val]>>=1;return};
	def let .["^"] {[val]^=1;return};
	def let .["v"] {[val]=0;return};
	def let .["n"] {return};
	delete val;
};
let heap{import lib "heap.0xmin";};
//#heap.unref<=>(){};//unref() & free does not fully work yet
//#heap.malloc..splice(0,0,{hlt});
//#heap.malloc..splice(-2,0,{hlt});
...(){
	let nextAddress{
		//#heap..splice(0,-0,{def ..this});
		0;
	};
	let m_class(class,argsLen,classConstructor,classDeconstructor)={
		//class:#Struct,constructor:#()->{@}
		let m_class=this..constructor;
		#class::{
			#class..proto=m_class..prototype;
			()={#..compile};
		};
		#class..prototype::{
			let new(){//:(...%[])->push[Context*]
				let rMemory = heap.malloc.inputs[0];
				r rMemory=this..length;
				let rMemory = heap.malloc.outputs[0];
				repeat 0 {:malloc;
					//quicker O(1) way of allocating memory
					let address= rMemory+1;//[%]*
					r address=r rMemory;
					r rMemory = [nextAddress];
					r rMemory += heap..return;
					[nextAddress] += r address;
				};
				repeat 1 call heap.malloc;
				#let i=this..length-1;
				repeat argsLen:{
					[r rMemory+i]=pop;//r arguments.(i);//argument
					#i=i-1;
				};
				classConstructor();
			};
			let addRef(){
				let rMemory=heap.malloc.outputs[0];
				pop rMemory;
				[r rMemory-#(heap.Page.prototype.data-heap.Page.prototype.isUsed)]+=1;
			};
			let delRef(){
				let rMemory=heap.malloc.outputs[0];
				pop r rMemory;
				[r rMemory-#(heap.Page.prototype.data-heap.Page.prototype.isUsed)]-=1;
				jump->..return if > 0;
				del();
			};
			#new::(){
				push r rMemory;
			};
			let del(){//:pop[this:Context*]
				classDeconstructor();
				call heap.free;
			};
		};
		#return=class;
	};
	let Context()={
		def let parent{0};//:Context*
		def let argument{0};//:FunctionInstance*||InbuiltFunction*
	}:>m_class(2)<:{
	};
	let spareReg=heap.malloc.nextReg.n+1;
	let FunctionInstance()={//extends Function
		let context{0};//:Context*
		let function{0};//:Function*
		r0 = ip;//r context = this.context
		jump->[ip+2];//jump->function
		def context;
		def function;
	}:>m_class(2)<:(){
		let vals={
			@0x200000F0;//-> @r0 = ip;   //r0 = functionInstance
			@0x31BF0020;//-> @jump->[ip+2]; //jump-> function
		};
		let rMemory=heap.malloc.outputs[0];
		let spare=spareReg;
		let i=0;
		repeat 2:{
			swm=#(vals[i]>>16);
			r spare = #(vals[i]&0xffff);
			[r rMemory+i]=r spare;
			#i=i+1;
		};
		swm=0;
	};
	let for_repeat(repeatNum,reg_i,do){//#(int,%,{@})->{@}
		repeat !!+repeatNum:{
			let i=reg_i;
			r i=repeatNum;
			def let loop{
				def do;
				r i-=1;
				jump->..this if > 0;
			};
		};
	};
	let getRecur(code){
		#return = code..flat..length;
	};
	let output;
};
//note: 'a b > c d' --> 'a (b > (c d))'
//m_ == # aka meta
let newFoo(code,function,argName)={//:Function
	let stackLevel=function.stackLevel+1||0;
	let scope{
		repeat !!argName:let ..this[""...argName]<->stackLevel;
		let ..proto=function.scope;
	};
	let numOfArgs=0;
	let block={...codeof code};
	let string=">";
	//this program does not clean up it's memory usage.
	//I have not learnt how to do that yet. This is fine for smaller lamda expressions.
	let addFoo(arg){//arg from heap
		//arg:Function*
		#set block{
			def let addFoo{
				let foo=FunctionInstance=();
				push r registers.context;//:Context*
					//new FunctionInstance
						push r registers.context;//:Context*
						push arg;//:Function*
						...set{:ifBlock;
							//if no context then don't add reference
							r registers.context|=0;
							jump->ifBlock..return if == 0;
							heap.ref(registers.context);
							def ifBlock..return;
						};
					foo.new();//:(pop Context*,Function*)->push FunctionInstance*
				//assume registers.context<14
				pop r #(registers.context+1);//:%FunctionInstance*
				pop r registers.context;//:%FunctionInstance*
				push r #(registers.context+1);
			};
		};
		#return=arg;
	};
	let addArg(arg,scope){//arg on stack 'arg'
		//arg:index, scope:
		let isNormalArgument=!arg[¬newFoo];
		#set block{
			def let addArg{
				repeat !!+isNormalArgument:...set{
					let currentContext=+registers..length;//:%Context*
					#currentContext = Context=() <-> currentContext;
					r currentContext = r registers.context;
					//let i = 2;//:%
					let argNumber=getArg(arg,scope);
					#set string{...(" "...+argNumber);};
					let getParentContext(){
						r currentContext = [r currentContext + currentContext.parent];
					};
					#let fast=1;
					repeat !!fast: repeat argNumber:getParentContext();
					repeat !fast: for_repeat(argNumber,i)<:getParentContext;
					push [r currentContext + currentContext.argument];//:push FunctionInstance*
					let arg<->currentContext;
					r arg=[sp];
					let next;jump->next if==0;
					heap.ref(arg);
					def next;
				};
				repeat !+isNormalArgument:...set{//arg is an input function
					#set string{...("i"...+output.inputFunctions..indexOf(arg));};
					r1 = arg;
					heap.ref(1);//handle refs
					push arg;//:push Function*
				};
			};
		};
		#return=arg;
	};
	let addCall(){//stack={foo} //'(foo>...) arg'
		#set string{"c"};
		#set block{...set{
			def let addCall{
				//assert:context=r0;
				let arg=1;
				let foo=2;
				pop r arg;//arg
				pop r foo;//foo
				push r registers.context;
				push r arg;
				call r foo;//ref counting is handled inside the function itself
				pop r arg;
				pop r registers.context;
				push r arg;
			};
		}};
	};
	let getArg(arg,scope){//assert:arg<=scope.stackLevel
		#return = scope.stackLevel-arg;
	};
	{
		//{arg} -> {arg;ret}->{arg;ret;ans}->{ans;ret} -> {ans}
		//let const_0=0;
		let context = Context=() <-> registers.context;//:%Context*
		let fooInstance = FunctionInstance=() <-> context;
		let contextParent=Context=() <-> 1;
		//assume: %fooInstance!=0
		//assume: fooInstance:%FunctionInstance*
		//note contextParent is unrefed and reffed so they cansle out 
		let arg=2;
		let ans=2;
		let ret=3;
		//assert: stack = {arg;ret}
		r ret = pop;//ret
		r arg = pop;//arg
		push = r ret;
		call newFoo.part1;
		//assert: stack = {ret}
		def block;
		jump->newFoo.part2;
	};
	repeat (arguments..length>1):
	#set output{
		null;//start of function
		def this;
	};
}::{
	let ..prototype{
		let swap{
			pop r1;//arg
			pop r2;//foo
			push r1;
			push r2;
		};
		let registers={
			def let context<->0;
			def let fooInstance<->0;
		};
	};
	let prototype=..this=();
	def let part1{
		...let prototype[0];
		%contextParent=[%fooInstance+fooInstance.context];
		{
			push r contextParent;//parent
			//contextParent would be reffed here
			let next;
			push r arg;//argument
			heap.ref(arg);
			heap.unref(fooInstance);
			//delete fooInstance;
			context.new();//:(parent:&sp,argument:&sp) -> push Context*
			pop r context;
		};
		//assert: stack = {ret}
		return;
	};
	def let part2{
		...let prototype[0];
		//assert: stack = {ret;ans}
		pop r ans;
		pop r ret;
		push r ans;//ans
		push r ret;//ret
		{:handleRefs;
			let temp=ret;
			push r context;
				r context=[sp];
				r temp = [r context + context.parent];
				let next;
				jump->next if==0;//ignore undefined parent contexts
				heap.unref(temp);//parent
				def next;
				#delete next;
				r context=[sp];
				r temp = [r context + context.argument];
				heap.unref(temp);//argument
			pop r context;
			heap.unref(context);
		};
		//assert: stack = {ans;ret}
		return;
		//assert: stack = {ans}
	};
};
let parse(code,i,function,hasRecur){
	let returnValue;//:function
	//!!hasRecur => recur>1
	let line=code;
	repeat !hasRecur:{
		#line=code[0][0];
		#output={//extension object
			:this;
			let maxRecur=getRecur(line);
			let mainFoo=function=newFoo=({});
			let inputFunctions={...let set arguments[1]};
			let functions{};
			def mainFoo<=>{...let mainFoo;}::{
				#let list=inputFunctions..labels,i1=0;
				repeat list..length:{#;
					let foo=inputFunctions[""...list[i1]];
					let foo[¬newFoo];//mark the input functions
					let mainFoo.scope[""...list[i1]]=foo;
					//push end;
					i1+=1;
				};
				#i1=0;
				repeat list..length:{#;
					//asume: '@[Page*-1]' == page.isUsed
					inputFunctions..splice(i1,0,{1});//inserts heap.Page.prototype.isUsed's so it can be unreferenced
					i1+=2;
				};
				{:main;
					let end{return};#end<->0;
					def block;
					let ans=2;//:%
					def let ..this.getAns{pop r ans};
					#stackLevel=0;
					return;
					def inputFunctions;
				};
			};
			delete this;
			//$undef mainFoo;
		};//:0xmin[]
		repeat !line:#:{}[]ERROR;
		#i=0;
	};
	let oldI=i;
	#i=+i;
	let args=0;
	recur output.maxRecur:
	repeat (i<line..length&&(line..length-oldI)): {
		let word=line[i];
		let continue=1;//:bool
		repeat (word=="("): {//zero cost abstraction
			#i+=1;
			repeat !!line[i][1]
				#:{}[]ERROR;//silent error
			recur output.maxRecur: 
			repeat !!line[i]: #returnValue=parse(line[i][0],0,function,1);
			#i+=2;
			#continue=0;
			#args+=1;
		};
		let word=line[i];
		repeat ((args<2) && (line[i+1]==">")):{//function a>b ==> (a){#return=b}
			#i+=2;
			let foo1=newFoo({},function,""...word);

			#returnValue=parse(line,i,foo1,1);
			{//removes repeated functions
				let r=output.functions..length;
				let i1=0;
				repeat r:{
					repeat ((""...output.functions[i1].string)==#(""...foo1.string)):{
						#r=0;//r = i1+1; aka break;
						$undef foo1;
						#foo1=output.functions[i1];
					};
					#i1+=1;
				};
				repeat (+r==output.functions..length):{
					#output.functions..splice(-0,0,{$def foo1});
				};
			};
			#function.addFoo(foo1);
			#set function.string{"(";...codeof foo1.string;")"};
			#continue=0;
			#args+=1;
		};
		let word=line[i];
		repeat ( (args<2) && !!word && (word!="(") && (word!=">")):{//word
			let value=function.scope[""...word];
			repeat !value:debugger (""...word);
			repeat !value#:{}[];//ERROR:value not defined
			#returnValue=function.addArg(value,function);
			#args+=1;
			#i+=1;
		};
		repeat(args>1):{
			#args-=1;
			#function.addCall();
		};
	};
	#oldI<->i;
	repeat !hasRecur repeat (args==0) #function.getAns<=>{};
	repeat !!hasRecur:#return = returnValue;
	repeat !hasRecur:#return = output;
};
let main=parse(lamda,lamda);
call main;
def let end{
	hault;
};
def main;
def newFoo;
def heap.clear;
def heap;