#"tptasm";#"len";
//TODO: fix stack memory leak in assembly method calls
import "std v1.0xmin";
...labelsof{
	let Trait(traitObj)={//#(data Trait)-> Trait & #(T:Type?)-> T & #(...)-> T
		//an abstraction to make injecting properties, and methods easier
		#constructor::{
			#return(typeObj)={//:(Type?)->Type

				#return = typeObj = typeObj||return;
				repeat(typeObj..length == 0): #typeObj::()={};
				#{
					let trait = constructor[¬Trait.traitNameLabel]||constructor;
					let typeObj[¬trait];
					let typeObj[¬trait]..prototype;
					let traitInstance <=> traitObj(typeObj);
					#addTraitToType(traitInstance,typeObj);
					#addTraitToType(traitInstance..prototype,typeObj..prototype);
				};
			};
			let return[¬Trait] = return[-1];
		};
	}::{
		let symbols{//similar to '#[derive!()]' in Rust
			let asMethod{
				let asm(foo,state,getInputs,getOutputs){
					meta.unimplemented();
					let skipRegs = 0xmin.Math.min(foo.inputs..length,foo.outputs..length);
					RegEnum(foo.regsUsed).blockScope(skipRegs)<:(reg){

					}::{

					};
				};// ¬ => default, property.use:#()->adds method to static
				let meta;// ¬ => defualt, #()->{} ; for methods with the form `m(label,...args){}`
			};
			let asConstructor{//only for invalid Container types
				let asm;// ¬ => default, property.use:#()->adds method to static
				let meta;// ¬ => defualt, #()->{} ; for methods with the form `m(label,...args){}`
			};
			let asProperty{
				let asm;
				let meta;
			};
			let private;//for private properties, only accessable by `typeObj[¬traitObj]`
			let traitNameLabel;
		};
		#symbols.asMethod.asm(method,object,state,getInputs,getOutputs){
			let this = object;
			let args = {...arguments};
			#args..splice(0,1);
			let pushedSelf;
			let pushedRegs = {};
			def getInputs()||{
				meta.repeat(method.regsUsed||0)<:(i){
					#pushedSelf = pushedSelf || (+i == +method.inputs.self);
					repeat !state.regState.isUsed(i):{
						push %i;
						#pushedRegs..splice(-0,0,{i});
					};
				};
			};
			repeat(!+pushedSelf&&!!method.inputs.self):{
				push %method.inputs.self;
				meta.if(!!+Pointer.isPointer(this)&&!this[¬Static])<:(){
					%method.inputs.self = %this;//%{@}*
				}||meta.if(!+Pointer.isPointer(this)&&!this[¬Static])<:(){
					%method.inputs.self = this;//{@}
				}<:(){
					%method.inputs.self = [this];//@{@}*
				};
			};
			call #(method.use(state||{let static=static},this)||method:>static.use());
			def getOutputs()||{
				let i = method.regsUsed;
				let len = pushedRegs..length;
				repeat len:{
					repeat !+pushedSelf pop %pushedRegs..splice(-1,1).(0);
				};
			};
		};
		...labelsof symbols;
		let isPublicByDefault = {};//:#const setting
		let addTraitToType(traitInstance,typeObj)=>{//
			let i = -1;
			let labels = traitInstance..labels;
			repeat labels..length{
				let name = labels[i+=1];
				let property = traitInstance[""...name];
				let typeObj[¬traitObj][""...name] = property;
				repeat(
					(!!isPublicByDefault && !!property[¬Trait.public]||!property[¬Trait.private])||
					( !isPublicByDefault && !!property[¬Trait.public]&&!property[¬Trait.private])
				):let typeObj[""...name] = property;
				repeat(property[¬Trait.asMethod.meta] != ()):#{
					let typeObj..prototype[""...name];
					let isDefaultMethod = property[¬Trait.asMethod.meta]== ¬;
					repeat !!isDefaultMethod:
						let typeObj[¬traitObj]..prototype[""...name] =
							typeObj..prototype[""...name] <=>
							#(){#return = property(this,...arguments)}
						;
					;
					repeat !isDefaultMethod:
						#typeObj..prototype[""...name] <=> property[¬Trait.asMethod.meta]
					;
				};
				repeat(property[¬Trait.asMethod.asm] != ()):#{
					let typeObj..prototype[""...name];
					let isDefaultMethod = property[¬Trait.asMethod.asm] == ¬;
					meta.if(isDefaultMethod)<:(){
						let typeObj[¬traitObj]..prototype[""...name] =
							typeObj..prototype[""...name] <=>
							#(state,getArguments,getOutputs){
								let args = {...arguments};
								#args..splice(0,1);
								let pushedSelf;
								let pushedRegs = {};
								def getArguments()||{
									meta.repeat(property.regsUsed||0)<:(i){
										#pushedSelf = pushedSelf || (+i == +property.inputs.self);
										repeat !state.regState.isUsed(i):{
											push %i;
											#pushedRegs..splice(-0,0,{i});
										};
									};
								};
								repeat(!+pushedSelf&&!!property.inputs.self):{
									push %property.inputs.self;
									meta.if(!!+Pointer.isPointer(this))<:(){
										%property.inputs.self = %this;
									}<:(){
										%property.inputs.self = this;
									};
								};
								call #(property.use(state.static||static,this)||property:>static.use());
								def getOutputs()||{
									let i = property.regsUsed;
									let len = pushedRegs..length;
									repeat len:{
										repeat !+pushedSelf pop %pushedRegs..splice(-1,1).(0);
									};
								};
							}::{
								let function = property;
							}
						;
						repeat !property.use let property.use(){
							#property:>static.use();
							#return = property;
						};
					}<:(){
						#typeObj..prototype[""...name] <=> property[¬Trait.asMethod.asm];
					};
				};
			};
		};
		let typeToTrait(typeObj){
			let typeObj[¬Trait] = Trait()<:(type){#return<=>typeObj};
		};
		let impl(typeObj,implData){//:Type 'Type:>Trait.impl((type){let a,b,c;})'
			#return = typeObj;
			repeat(typeObj..length == 0): #typeObj::()={};
			repeat !!implData let traitInstance = implData(typeObj);
			repeat !implData let traitInstance = typeObj;
			let typeObj[¬typeObj];
			let typeObj[¬typeObj]..prototype;
			let typeObj[¬Trait] = Trait(implData)::{
				let .[¬traitNameLabel] = typeObj;
			};
			#addTraitToType(traitInstance,typeObj);
			#addTraitToType(traitInstance..prototype,typeObj..prototype);
		};
	};
	repeat 0 #{
		let ExampleTrait1(type){
			let staticProperty1{//'type.staticProperty1'
				print("Hello, world!");
				@return;
			}::{};
			let ..prototype{
				let property1{//'type().property1'
					let value;
					r0 = value;
					@call property;
				};
			};
			let method1(object,arg1,arg2){//'type.method1(type(),4,5)'
				object.value<->object.value + arg1*arg2;
				#return = object;
			}::{let .[¬Trait.asMethod.meta]};//'type().method1(4,5)'
		}:>Trait();
		let type()={
		}:> ExampleTrait1();
		type().method1();
	};
	let Type = #(){
		let Type<=>Trait()<:(type){//similar to Trait, but for objects
			repeat !type.[¬alreadyCalled] #type::()={
				repeat !..this[¬type]
					#let ..this[¬type]{...labelsof this},..this[¬Type.symbols.type] = type;
			};
			let type.[¬alreadyCalled];
		}¬::{
			let addType(obj,type){
				#return = obj;
				#let obj[¬type];
			};
			let isType(type){//:(#{})->#{}?
				#return = type[¬Type];
			};
			let isInstance(type){//:(#{})->#{}?
				#return = type[¬Type.symbols.type]];
			};
			let symbols;
			let symbols.type;
		};
		let alreadyCalled;//:symbol
		#return = Type;
	}();
	let ToType<=>Trait()<:(type){
		let set toType(object,castType){//:castType
			#return = toType[¬castType](object)
				||castType[¬ToType].fromType[¬type](object,type)
				||{throw "cannot convert types"}
			;
		}::{let .[¬Trait.asMethod.meta]};
		let set fromType(object,castType){//:type
			#return = fromType[¬castType](object)
				||castType[¬ToType].toType[¬type](object,type)
				||{throw "cannot convert types"}
			;
		}::{let .[¬Trait.asMethod.meta]};
	};
	let Wrapper<=>Trait()<:(type,innerType){
		let innerType = innerType||¬;
		let unwrap(){
			#delete this[¬type];
		};
	}¬::{
		let Wrap(type,innerType){//:Trait ; includes Wrapper trait
			#return = Wrapper(type)::(innerObject)={
				#{
					let object = ..this;
					#wrap(object,innerType()||innerObject,type);
				};
			};
		};
		let wrap(wraperObj,wrapeeObj,type){//:#<W=Wrapper,T>(obj:~W<T>,T,Type<T>?)->mutate obj:W<T>
			#return = wraperObj;
			let type = type||wraperObj..constructor;
			#let set wraperObj[¬type]::{
				...labelsof wraperObj;
			};
			meta.if(wraperObj.wraperObj == ())<:(){
				#wraperObj::{
					...labelsof wrapeeObj;
				};
			}<:(){
				#wraperObj..splice(-0,0,{wrapeeObj});
				#wraperObj::{
					...labelsof ..splice(-1,1)[0];
				};
			};
			#wraperObj..proto = {}::{
				let set:..super = wrapeeObj..proto;
				let set:..proto = wraperObj..proto;
			};
		};
		let ..prototype{
			let unwrap(){
				#this
			};
		};
	};
	let Struct<=>Trait()<:(type){//:Trait<()->[]ram>
	}¬::{
		let Struct = ..this;
		let Object(object)={//:{@}&any
			//any object, of any size
			//Is userally stored on the heap, but can also be stored on static,regs,stack etc...
			...codeof object;
		}:>Struct():>Wrapper.Wrap();
		let Container(object)={//:<T>(T)->~T ;
			//A container contains an object that is yet to be initialised.
			//Note, using type annotation '~' for the more general container type
				//Read as 'approximately'. e.g. '{let a = ¬} : #~{a:#int}'
			//May not contain a valid object of type.
			//Can be used for @ constructors
			//e.g.
				//Calling @malloc returns a Container,
				//Then calling a @constructor will turn the container into a valid Object
			...codeof object;
		}:>Struct():>Wrapper.Wrap();
		#Heap:>Trait.impl()<:(type){
			let fill(object,value,tempReg){
				let reg = RegEnum();
				mask = value;
				meta.if(object[¬Static])<:(){
					meta.forEach(object..@)<:(v,i){
						[v] = value;
					};
				}<:(){//assert: object:%[]heap
					let heapObject = heap.Object();
					let size <-> tempReg;
					%size = [%obj-(-heapObject.next)];
					%size -= %object;
					jump->return..return if == 0;
					for.doFor(size,(i){},(continue){jump->continue if!=0},(i){%i-=1})<:(i){
						[%object+%i] = value;
					}
				};
				mask = 0;
			}::{let .[¬Trait.asMethod.meta] = ¬;};
		};
		delete Struct;
	};
	let Pointer(typeOrObject,isType,TEST)={//(T|Type<T>,()|{}):T*
		let ..this[¬..constructor];
		...codeof{
			let type,object;
			#isType = isType || Type.isType(typeOrObject);
			meta.if(!!isType)<:(){//%T*
				#type = typeOrObject;
				#object = type();
			}<:(){//@T*|%T*
				#object = typeOrObject;
				#type = object..constructor;
			};
			#..this[¬..constructor]={
				let size = object..@..length;
				let data = object;
				let type = object..constructor;
			}::{
				#..proto = pointer..prototype;
			};
			@((object<->0)||0);
			#..this::{...labelsof ..this[¬..constructor];};
			#..this::{...labelsof (object)::{#..compile};};
			let ..this..proto = {}::{
				let ..super = object..proto;
				let ..proto = pointer..prototype;
			};
		};
	}:>Type():>Wrapper()::{
		let isPointer(label){
			#return = label[¬Pointer]||¬;
		};
	};
	let OuterType<=>Trait()<:(type){//type of wrapper, %|{@}
		#type::()={
			let .[¬OuterType] = ..constructor;
		};
		#let set:set;
		#let set:clone;
	};
	let Index(onObject,propertyIndex)={//:#<P:O+ & #[]O?, O:{@}>(P?,O?)-> O+P ; '@[%object+property]' | '@%object+=property
		...codeof propertyIndex;
		let set .[¬constructor]{
			let object = onObject;
			let property = propertyIndex;
		};
		...labelsof .[¬constructor];
		#Wrapper.wrap(this,propertyIndex);
	}:>OuterType():>Wrapper();
	let Item(onObject,property)={//:#<P:[]O,O:{@}>(P?,O?)-> []O
		...codeof property;
		let set .[¬constructor]{
			let object = onObject;
			let property = property;
		};
		...labelsof .[¬constructor];
		#Wrapper.wrap(this,property);
	}:>OuterType():>Wrapper();
	...labelsof Struct;
	let usize(value)={def value||¬0};//:Type<unsigned @>
	let int(value)={def value||¬0};//:Type<@>
	let Optional(noneObject,someType)={//:#(value,Type)->Optional
		let None,Some;
		let None = #(){
			#return <=> noneObject;
			let return[¬None];
		};
		let Some = #(value){
			#value = value || {0};
			#return = value;
			let value[¬Some];
			let value.[¬someType]{value};
		}:>Wrapper();
	}:>Type():>Trait.impl()<:(type){
		let set None, Some;
	};
	let NullableReference:>Type()::()={
		#return = Pointer(...arguments);
		let return[¬NullableReference];
	}:>Optional[¬Trait](Pointer)::{
		let None(){
			return = Pointer({}<->0):>Type.addType(NullableReference);
		}:>Type();
		let Some(obj){
			return = Pointer(obj):>Type.addType(NullableReference);
		}:>Type();
	};
	let Function<=>Trait()<:(function,inputTypes,returnTypes){//{@}
		let inputs<=>inputTypes||{};
		let outputs<=>returnTypes||{};
		let regsUsed;
		let use = #(state){
			#:static.use(this);
		};	
		let call = #(){
			#function.use();
		};
		let reg = RegEnum();
	};
	let Method<=>Trait()<:(function,inputTypes,returnTypes){//{@}
		#function:>Function(inputTypes,returnTypes);
		let inputs{
			def let self;//
			...codeof labelsof inputTypes;
		};
		let outputs{
			def let self = inputs.self;
			...codeof labelsof returnTypes;
		};
		let regsUsed;
		let type[¬Trait.asMethod.asm] = ¬;
		let use = #(){
			;
		};	
		let call = #(){
			;
		};
		let reg = RegEnum();
	};
	let Allocator<=>Trait()<:(type){
		let alloc;//#(self)->{@} & self:(Container|Object)&[]type
		let free;//#(self)->{@}
		let New;//:#(type)->type; generates a new memory area of this allocator type
	};
	let StaticData = Allocator():>Trait.impl()<:(type){//#()->unallocated []static
		let Static;
		let free(label){
			undef label;
			#return = label;
		}::{let .[Trait.asMethod.meta] = ¬;};
		#use::(label){
			;
		}::{let .[Trait.asMethod.meta] = ¬;};
	}:>Allocator():>Wrapper.Wrap():>Type();
	let Stack(){
		;
	}:>Allocator():>Wrapper.Wrap():>Type():>Trait.impl()<:(type){
		#alloc(label){//#<T>(%Container(T))->{@(%)->Container(T)}
			meta.if(!!label[¬Container])<:(){
				sp -= label..@..length;
			}<:(){
				def meta.forEach(label..@,(v,i){push i});
			};
			repeat(+label!=0) %label = r0;
			//repeat !label[¬Container]:label..constructor[¬Constructor](label);
		}::{
			let .[Trait.asMethod.meta] = ¬;
		};
		#free(label){
			meta.if(!!label[¬Container])<:(){
				sp -= label..@..length;
			}<:(){
				def meta.forEach(label..@,(v,i){push i});
			};
		};
	};
	let Heap(){//#()->unallocated []heap
		#this<=>this...heap.Object();
	}:>Allocator():>Wrapper.Wrap():>Type():>Trait.impl()<:(type){
		#let alloc(label){//#<T>(%Container(T))->{@(%)->Container(T)}
			r0 = (label[¬Pointer].size||label..@..length);
			heap.malloc.use();
			repeat(+label!=0) %label = r0;
			//repeat !label[¬Container]:label..constructor[¬Constructor](label);
		}::{
			let .[Trait.asMethod.meta] = ¬;
		};
		#let free(heapObject){//#()->{@(%[]heap)->mutate heap}
			repeat(+label!=0) r0 = %heapObject;
			heap.free.use();
			//repeat !label[¬Container]:label..constructor[¬Constructor](label);
		}::{
			let .[Trait.asMethod.meta] = ¬;
		};
	};
	let Register:>Allocator()::(contains,register)={
		repeat !!register: ..this <-> register;
		let set .[¬..constructor]{
			let register = register;
		};
	}:>OuterType():>Type():>Wrapper.Wrap():>Trait.impl()<:(type){//:#<T>(T)-> %T; %register
		let:set(label1,label2){
			meta.unimplemented();
			meta.if(!!label2[¬Register])<:(){
				%label1 = %label2;//`% = %`
			}<:meta.if(!!label2[¬Static])<:(){
				%label1 = [label2];//`% = [@]`
			}<:(){
				%label1 = label2;//`% = #`
			};
		}::{let .[¬Trait.asMethod.meta] = ¬;};
		let:set_deref(label1,label2){
			meta.unimplemented();
			meta.if(!!label2[¬Register])<:(){//`% = [%]`
				%label1 = [%label2];
			}<:meta.if(!!label2[¬Static])<:(){//`% = [[@]]`
				%label1 = [label2];
				%label1 = [%label1];
			}<:(){//`% = #`
				%label1 = [label2];
			};
		}::{let .[¬Trait.asMethod.meta] = ¬;};
		let:deref_set(label1,label2,tempReg){//(%*,%,%?)->{@} & {@mutate *%}
			meta.unimplemented();
			meta.if(!!label2[¬Register])<:(){//`% = [%]`
				[%label1] = %label2;
			}<:meta.if(!!label2[¬Static]||!!label2[¬Struct])<:(){//`% = [[@]]`
				[%label1] = label2;
			}<:(){//`% = #`
				meta.if(!!tempReg)<:(){
					push [label2];
					[%label1] = pop;
				}<:(){
					%tempReg = [label2];
					[%label1] = %tempReg;
				};
			};
		}::{let .[¬Trait.asMethod.meta] = ¬;};
	};
};
...labelsof{
	let DynLenObject(data)={//object with dynamic size
		def let slice = constructor.Slice()||{
			#def let size<=>usize(0);//:@usize
			#def let data<=>NullableReference(Object,{});//:@any*?
		};
		#Wrapper.wrap(this,slice);
		def let capacity<=>usize(0);//:@usize
	}:>Type():>Trait.impl((type){
		//remember: data must be a pointer otherwise all refs will have to be updated whenever the data is realloced
		let meta_set(label,data){
			#return = label;
			#return.data <=> Pointer(data,());
			#return.size <=> usize(data..@..length);
			#return.capacity <=> usize(data..@..length);
		}::{let .[¬Trait.asMethod.meta]=¬};
		let push{//:@(%(self&DynLenObject)*,ref:%@*)->([%ref]: %(@self*?)*) & mutate self
			let static = Static();
			let reg = RegEnum();
			let regsUsed;
			let inputs = {
				def let self = reg()<=>Pointer()<:DynLenObject();//:%DynLenObject*
				def let size = reg()<=>usize();//:%usize
			};
			let outputs = {
				def let self = inputs.self;
				def let newItem = +inputs.size <=> Pointer(Container);//%@[size]* & %([]*dynArray.data)
			};
			{:pushFunction;
				let self = inputs.self;
				let temp = reg();
				let temp2 = reg();
				#reg = RegEnum(0xmin.Math.max(heap.resize.regsUsed,heap.malloc.regsUsed,heap.free.regsUsed));
				let store = {
					let self = reg()<=>outputs.self;

					let newSize = reg()<=>usize();
				};
				{:sizeCheck;
					:handleCapacity;
					let newSize <-> inputs.size;//share
					meta.assert(+outputs.newItem == +inputs.size);
					//assume: %outputs.newItem == %inputs.size
					%newSize += [%self + self.size];
					%newSize - [%self + self.capacity];
					if <= 0 !signed jump -> {:returner;
						let temp = temp;
						%temp = [%self + self.size];
						[%self + self.size] = %newSize;
						%outputs.newItem = %temp;
						%outputs.newItem += [%self + self.data];
						return;
					}:>static.use();
					%store.self = %self;
					%store.newSize = %newSize;
					{:growArray;
						%newSize <<= 1;
						[%self + self.capacity] = %newSize;
						repeat (+newSize != 1): r1 = %newSize;
						r0 = [%self + self.data];
						let successfulResize;
						if == 0 jump -> static.use()<:{:handleNullDataPointer;
							r0 = %newSize;
							call heap.malloc;
							[%store.self + store.self.data] = r0;
							jump -> successfulResize;
						};//handle null
						let newSize = ¬;
						call heap.resize;
						if !sign jump -> successfulResize::{
							%outputs.self = %store.self;
							let self = outputs.self;
							%temp = [%self + self.size];
							[%self + self.size] = %store.newSize;
							%outputs.newItem = %temp;
							%outputs.newItem += [%self + self.data];
							return;
						};
						{
							r0 = [%store.self + store.self.capacity];
							call heap.malloc;
							let newArray = Pointer(self.data..constructor)<->heap.malloc.outputs[0];//%Object* & %[]heap
							let reg = RegEnum(1);
							let oldArray = Pointer(self.data..constructor)<->reg();
							%oldArray = [%store.self + store.self.data];
							{:moveArray;
								#reg<->2;
								reg.weakScope()<:(){
									for.doFor(reg())
										<:(i)=>{
											%i = [%store.self + store.self.size];
											%i -= 1;
											if == 0 jump->return..return;
										}<:(i,continue){if >= 0 jump->continue;}
										<:(i){%i -= 1;}
									<:(i){
										let item <-> temp2;
										%item = [%oldArray + %i];
										[%newArray + %i] = %item;
									};
								};
								//assert: newArray:%DynLenObject().data*
							};
							[%store.self + store.self.data] = %newArray;
							r0 = %oldArray;
							call heap.free;
						};
						def successfulResize;
					};
				};
			};
			#reg<->reg.max;
			def static.memory;
			#regsUsed = reg;
		}::{
			let use(state){
				#{
					let tempLabel = ..this.static;
					delete ..this.static;
					#:static.use(..this);
					let ..this.static = tempLabel;
					delete tempLabel;
				};
				#heap.malloc.use();
				#heap.free.use();
				#heap.resize.use();
				#return = ..this;
			};
			let .[¬Trait.asMethod.asm](newItem,pushFunction,state,getInputs,getOutputs){
				def let block = RegEnum(this.regsUsed).blockScope(2)<:(reg)=>{
					let isNumber = #((0+newItem)==(0+newItem))&&!(newItem..constructor||newItem[¬Static]||newItem[¬Pointer]);
					#newItem = newItem || {0};
					meta.if(!!+Pointer.isPointer(this))
						<:(){%inputs.self = %this}
						<:(){%inputs.self = this}
					;
					repeat !newItem throw "method 'DynLenObject.push' requires an object";
					%inputs.size = #((+isNumber&&newItem) || (newItem[¬Pointer].size||newItem..@..length));
					call ..this.use();
					def pushFunction(newItem,isNumber)||meta.if(!+isNumber)<:(){
						let item = newItem..@;
						meta.forEach(item)<:(v,i,a){
							[%outputs.newItem] = v;
							%outputs.newItem += 1;
						};
						%outputs.newItem -= item..length;
					};//#(%[]array*,{@})->{@}
				};
				#block::{
					repeat !!getInputs {
						#meta.if(!getOutputs)<:(){
							push<=>{sp-=push..length};
						}<:(){
							undef push;
						};
						def getInputs(state,this,return,2);//2 inputs
					};
					repeat !!getOutputs {
						#meta.if(!getInputs)<:(){
							pop<=>{sp+=pop..length};
						}<:(){
							undef pop;
						};
						def getOutputs(state,this,return,2);//2 outputs
					};
				};
				delete block;
			};
		}:>static();
	});
	let DynLenObject.Slice()={
		def let size<=>usize(0);//:@usize
		def let data<=>NullableReference(Object,{});//:@any*?
	}:>Type():>Trait.impl((type){
		let meta_set(label,data){
			#return = label;
			#return.data <=> Pointer(data,());
			#return.size <=> usize(data..@..length);
		}::{let .[¬Trait.asMethod.meta]=¬};
		let printString = {//:@(self:%*)->mutate terminal
			let regsUsed = 0;
			let regs = RegEnum();
			let inputs = {
				def let self = Pointer()<:DynLenObject.Slice()<->0;
			};
			let outputs = {
				def let self = inputs.self;
			};
			regs.blockScope()<:()={
				...labelsof inputs;
				#return = #(reg)=>{this};
				let const_0 = reg();
				let array = Pointer()<:Object() <-> reg();
				let array.size = usize()<->reg();
				%array = [%self + self.data];
				%array.size = [%self + self.size];
				%const_0 = 0;
				r0 - %array.size;
				reg.weakScope()<:(reg){
					for.doFor(reg(),(),(i,to){
						%i - %array.size;
						jump->to if<0;
					},())<:(i){
						send %const_0 [%array + %i];
					};
				};
			}();
			return;
		}::{
			let .[¬Trait.asMethod.asm] = ¬;
		};
		let printArrayObject = {//prints array data
			let used(){
				#return = this:>static.use();
			};
			let inputs{
				def let self = Pointer()<:DynLenObject.Slice()<->0;
			};
			let outputs{
				def let self = inputs.self;
			};
			...labelsof inputs;
			def let intPrinter = {
				let reg = RegEnum();
				let obj = reg();
				let size = reg();
				%size = [%self+self.size];
				%obj = [%self+self.data];
				let const_0 = reg();
				print("@",const_0);
				#let const_0.is0 = 1;
				print.register(obj,const_0);
				print(":",const_0,{});
				print.register(size,const_0);
				print("{",const_0,{});
				let temp = {repeat 2 reg()};
				{:forLoop;
					let max = size;
					//max:%int !signed & []
					let i = temp[0];//:%obj+ !signed
					%max|0;
					jump->forLoop..return if==0;//"{}"
					%i = 0;
					def let loop;
					{:do;
						let v = temp[1];//:%[]obj
						%v = [%obj+%i];
						%v &= 0xff;
						print.number.hexChar(v,const_0);
					};
					%i+=1;
					%i-%max;
					jump->forLoop..return if==0;
					{:onLoop;
						print(",",const_0,{});
					};
					jump->loop;
				};
				print("}\n");
			}:>(a){(){a}}():>reg.blockScope();
			let regsUsed = 0;
		}::{
			let .[¬Trait.asMethod.asm] = ¬;
		};
		let print = printArrayObject;
		let fill{
			let .[¬Trait.asMethod.asm] = ¬;
			let use(state){#;
				#return = ..this;
				#static.use(..this);
			};
			let regsUsed;
			let reg = RegEnum();
			let inputs{
				def let self=Pointer(type())<->reg();
				def let value=usize()<->reg();
			};
			let outputs{
				def let self=inputs.self;
			};
			...labelsof inputs;
			${:block;
				let i = reg();
				let data = Object()<->reg();
				%i = [%self+self.size];
				%data = [%self+self.data];
				jump->block..return if == 0;
				for.doFor(i,(){},(continue){if>=0 jump->continue},(){i-=1})<:(){
					[%data+%i]=value;
				}
			}:>(a){(){a}}():>reg.blockScope({self});
			return;
			#regsUsed <-> 0;
		};
	});
	#DynLenObject:>Trait.impl()<:(type){
		let printArrayObject = Slice.printArrayObject;
		let printString = Slice.printString;
	};
	let DynArray(type,length)={//:<T1,T2> T[T1]
		#return = DynLenObject();
	}:>Type();
	let RefList()={
		#return = RefList.OwnedSource();
	}:>Type():>Trait.impl()<:(type){//for many to one a->b<-c
		//RefList is a type of smart pointer,
		let RefObject()={//:Type{([]source&{@}*)*,source:OwnedSource,@any}
			let data;
			def let itemRef <=> Pointer()
				<:Item(OwnedSource().refs,Pointer()::{#object=data})
			;
			def let owner <=> Pointer(self);
			def data <=> Object();
		}:>Type();
		let OwnedSource()={//:Type<:DynLenObject<:Ref*[]
			def let refs <=> DynLenObject();//:DynArray<owned<*>>
			#Wrapper.wrap(this,refs);
			let [¬OwnedSource]{...labelsof this};
		}:>Type():>Trait.impl()<:(type){
			let addRef{
				let .[¬Trait.asMethod.asm] = ¬;
				let use(state){#;
					#return = ..this;
					repeat(..defs[0]!=mallocRef):{
						#:static.use(..this);
					};
					#:DynLenObject.push.use(state);
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{
					def let self = Pointer(OwnedSource())<->0;
					def let ref = Pointer(RefObject())<->1;
				};
				let outputs{
					def let self = Pointer(OwnedSource())<->0;
					def let newItem = Pointer(RefObject)<->1;
				};
				{
					#reg<->DynLenObject.push.regsUsed;
					#let store{repeat 1 reg()};
					#let store.ref = #({}<=>inputs.ref)<->store[0];
					@%store.ref = %inputs.ref;
					@%DynLenObject.push.inputs.size = 1;
					@call DynLenObject.push;
					#meta.assert(+outputs.self==+DynLenObject.push.outputs.self);
					#meta.assert(+outputs.newItem==+DynLenObject.push.outputs.newItem);
					@[%DynLenObject.push.outputs.newItem] = %store.ref;
					//$test;
					@return;
				};
				#regsUsed <-> reg;
			};
			let mallocRef{
				let .[¬Trait.asMethod.asm](objectToRef){
					RegEnum(..this.regsUsed).blockScope()<:(reg)=>{
						def meta.if(Pointer.isPointer(this))<:(){
							r0 = %this;
						}<:(){
							r0 = this;
						};
						repeat !!objectToRef meta.if(!!objectToRef..constructor)<:(){
							r1 = objectToRef..@..length;
						}<:(){
							r1 = objectToRef;
						};
						call ..this.use();
					}::{#pop..splice(-2,2)};
				};
				let mainBlock;
				let use(state){#;
					#return = ..this;
					#:static.use(..this);
					#:static.use(heap.malloc);
					#
					repeat (mainBlock..length == 0):
						#mainBlock::{
							def addRef;
						};
						#addRef.use();
					;
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{
					def let self = Pointer(OwnedSource())<->reg();
					def let size = usize()<->reg();
				};
				let outputs{
					def let self = Pointer(OwnedSource())<->0;
					def let newItem = Pointer(RefObject().data)<->1;
				};
				{
					let newRef = Pointer()<:Container()<:RefObject()<->malloc.outputs[0];
					#reg<->0xmin.Math.max(addRef.regsUsed,heap.malloc.regsUsed);
					#let temp = reg();
					#let temp_self <-> temp;
					#let refSize = RefObject()..@..length;
					%temp_self = %inputs.self;
					r0 = %inputs.size;
					r0 += refSize;
					call heap.malloc;
					[r0+newRef.owner] = %temp_self;
					%addRef.inputs.ref = r0;
					%addRef.inputs.ref += refSize;
					%inputs.self = %temp_self;
					def mainBlock;//does self.push
					let newItem = addRef.outputs.newItem;
					[%newItem-(refSize-newItem.itemRef)] = %newItem;
				};
				#regsUsed <-> addRef.regsUsed;
			};
			let unref{
				let .[¬Trait.asMethod.asm] = ¬;
				let use(state){#;
					#return = ..this;
					#:static.use(..this);
					#:heap.free.use();
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{
					def let self = Pointer(OwnedSource())<->reg();
					def let ref = Pointer(RefObject())<->reg();
				};
				let outputs{let self = inputs.self};
				let static = Static();
				{
					...labelsof inputs;
					reg.weakScope()<:(reg){:validateRef;
						let fail{
							r0 | -1;
							return;
						}:>static.use();
						let item <-> reg();
						{
							#item <=> Pointer()<:Item(self.data,RefObject());//:%RefObject&[](OwnedSource().data&RefObject[])
							%item = [%ref+ref.itemRef];
							%ref - [%item];
							if != 0 jump -> fail;
						};
						let index <-> item;
						#index <=> usize();
						{
							%index -= [%self+self.data];
							if < 0 !signed jump -> fail;//assert:index>=0
							%index - [%self+self.size];
							if >= 0 !signed jump -> fail;//assert:index<self.size
							//assert: ref is in bounds
						};
						#regsUsed<->reg;
					};
					let itemRef <-> reg();
					#itemRef <=> ref.itemRef;
					%itemRef = [%ref+ref.itemRef];
					let endItem <-> reg();
					#endItem <=> Pointer(RefObject());
					{
						%endItem = [%self+self.data];
						%endItem += [%self+self.size];
						%endItem -= 1;
						%endItem = [%endItem];
					};
					[%itemRef] = %endItem;
					{:updatePointers;
						[%endItem+endItem.itemRef] = %itemRef;
					};
				};
				return;
				def static;
				#regsUsed<->0xmin.Math.max(regsUsed,reg);
			};
			let unrefAll{
				let .[¬Trait.asMethod.asm] = ¬;
				let use(state){#;
					#return = ..this;
					#:static.use(..this);
					#:heap.free.use();
					#:unrefRef.use();
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{def let self = Pointer()<:OwnedSource()<->reg()};
				let outputs{def let self = inputs.self};
				let reg1 = RegEnum(heap.free.regsUsed);
				...labelsof inputs;
				repeat 0 {push %inputs.self;
					let array<->reg1();
					#array<=>self.data;
					%array = [%self+self.data];
					{:loop;
						let ref = RefObject()<->reg();
						for.doFor(reg1()<=>usize(),
							(i){
								%i = [%self+self.refs.size];
								%i -= 1;
								jump->loop..return if <= 0 !signed;
							},
							(i,continue){jump->continue if >= 0 !signed},
							(i){%i-=1}
						)<:(i){
							%ref = [%array+%i];
							{:dropReference;
								heap.unref(ref,unrefRef,{});
							};
						};
						//heap.unref(self,unrefRef,{});
					};
					def let resizeArray{
						...labelsof inputs;
						repeat 0: ...{:drop;
							r0 = %array;
							call heap.free;
						};
						repeat 0: ...{:shrink;
							#use::(){
								#heap.resize.use();
							};
							call heap.resize;
							#regsUsed <-> heap.resize.regsUsed;
						};
					};
				pop %inputs.self};
				[%self+self.size] = 0;
				return;
				#regsUsed <-> 0xmin.Max(regsUsed,reg,reg1);
			};
			let unrefRef{
				let use(state){#;
					#:static.use(..this);
				};
			};
		};
	}¬::{
	};
	let Process()={//type
		def let ownedObjects<=>RefList.OwnedSource(Process);
		def let weakReferences<=>RefList.WeakSource(Process);
		def let objectReferences<=>RefList(Object);
		def let references{0};//Process*[]*
		def let ownedStaticObjects{0};//
		def let state{
			def let regs{//@%[]
				...codeof{
					let enum = meta.enum(0);
					repeat 16 @enum();
				};
			};
			def let stack{0};//@(Object&Stack&{@})*
		};
	}:>Type()<:Trait.impl()<:(type){
		let malloc{
			let .[¬Trait.asMethod.asm] = ¬;
			let use(state){#;
				#return = ..this;
				#static.use(..this);
			};
			let regsUsed;
			let reg = RegEnum();
			let inputs{};
			let outputs{};
			{
				...do;
				return;
			};
			#regsUsed <-> reg;
		};
		let free{
			let .[¬Trait.asMethod.asm] = ¬;
			let use(state){#;
				#return = ..this;
				#static.use(..this);
			};
			let regsUsed;
			let reg = RegEnum();
			let inputs{};
			let outputs{};
			{
				
				return;
			};
			#regsUsed <-> reg;
		};
	};
	let printObject{//:@(%)->mutate
		let reg = RegEnum();
		let inputs{
			def let obj = heap.Object.pointer=() <-> 0;
		};
		let outputs{};
		//almost same code as DynLenObject.Slice.printArrayObject
		def:{
			let obj = heap.Object.pointer=()<->reg();
			let size = reg();//:%sizeOf obj.data
			%size = [%obj-(-obj.next)];
			%size -= %obj;
			let const_0 = reg();
			print("@",const_0);
			#let const_0.is0 = 1;
			print.register(obj,const_0);
			print(":",const_0,{});
			print.register(size,const_0);
			print("{",const_0,{});
			let temp = {repeat 2 reg()};
			{:forLoop;
				let max = size;
				//max:%int !signed & []
				let i = temp[0];//:%obj+ !signed
				%max|0;
				jump->forLoop..return if==0;//"{}"
				%i = 0;
				def let loop;
				{:do;
					let v = temp[1];//:%[]obj
					%v = [%obj+%i];
					print.number.hexChar(v,const_0);
				};
				%i+=1;
				%i-%max;
				jump->forLoop..return if==0;
				{:onLoop;
					print(",",const_0,{});
				};
				jump->loop;
			};
			print("}\n");
		}:>(a){(){a}}():>reg.blockScope();
		return;
		let use(){
			#..this[¬Static].use();
		};
		let regsUsed = 0;
	}:>static();
	#heap.Object:>Trait.impl()<:(type){
		let print<=>printObject;
		#print::{
			let [¬Trait.asMethod.asm] = ¬;
		};
	};
};
let String(string){
	let stringObj = heap.Object(string):>static.use().data[0];
	let stringObj.print = stringObj.printString;
	#return = DynLenObject().meta_set(stringObj):>static.use();
};
let str(string){
	let stringObj = heap.Object(string):>static.use().data;
	#return = DynLenObject().meta_set(stringObj).slice:>static.use();
};
repeat 0 {:example;
	let string = "Hello, world":>static.use().data;
	let list = DynLenObject().meta_set(string):>static.use();
	list.print();
	list.push("!");
	print("\n");
	list.print();
	def static.memory;
	def heap.data;
};