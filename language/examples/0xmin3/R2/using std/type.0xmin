#"tptasm";#"len";
//TODO: fix stack memory leak in assembly method calls
import "std v1.0xmin";
...labelsof{
	let Trait(traitObj)={//#(data Trait)-> Trait & #(T:Type?)-> T & #(...)-> T
		//an abstraction to make injecting properties, and methods easier
		#constructor::{
			#return(typeObj)={//:(Type?)->Type
				#return = typeObj = typeObj||return;
				repeat(typeObj..length == 0): #typeObj::()={};
				#{
					let trait = constructor[¬Trait.traitNameLabel]||constructor;
					let typeObj[¬trait];
					let typeObj[¬trait]..prototype;
					let traitInstance <=> traitObj(...arguments);
					#addTraitToType(traitInstance,typeObj);
					#addTraitToType(traitInstance..prototype,typeObj..prototype);
				};
			};
			let return[¬Trait] = return[-1];
		};
	}::{
		let symbols{//similar to '#[derive!()]' in Rust
			let asMethod{
				let asm;// ¬ => default, property.use:#()->adds method to static
				let meta;// ¬ => defualt, #()->{} ; for methods with the form `m(label,...args){}`
			};
			let asConstructor{//only for invalid Container types
				let asm;// ¬ => default, property.use:#()->adds method to static
				let meta;// ¬ => defualt, #()->{} ; for methods with the form `m(label,...args){}`
			};
			let asProperty{
				let asm;
				let meta;
			};
			let private;//for private properties, only accessable by `typeObj[¬traitObj]`
			let traitNameLabel;
		};
		let derive{
			let method{
				let asm(foo,selfObject,state,getInputs,getOutputs,bool_derefSelf){//regEnum
					#this = this||selfObject;
					let saveRegs::{#;//regsUsed&~outputs
						meta.repeat(foo.regsUsed)<:(i){..splice(0,-0,{i})};
					};
					let push,pop;
					#meta.forEach(saveRegs)<:(v,i){
						#push..splice(-0,0,{push %v});
						#pop..splice(+0,0,{pop%v});
					};
					//let pushedSelf = saveRegs..indexOf(+foo.inputs.self);
					let hasSelf = foo.inputs.self;
					let inputs,outputs;
					def (inputs=getInputs()||¬)||push;
					def let assignExtraInputs{
						repeat(!inputs&&!!hasSelf):{
							meta.if(!!this[¬Static])<:(){
								meta.if(!!bool_derefSelf)<:(){
									%foo.inputs.self = [this];//self:%@ ; this:{@}
								}<:(){
									%foo.inputs.self = this;//self:%{@}* ; this:{@}
								};
							}<:(){
								meta.if(!!bool_derefSelf)<:(){
									%foo.inputs.self = [%this];//self:%{@} ; this:%{@}*
								}<:(){
									%foo.inputs.self = %this;//self:%{@}* ; this:%{@}*
								};
							};
						}
					};
					def let callFoo{call #(foo.use()||foo[¬Static].use()||foo:>static.use())};
					def (inputs=getOutputs()||¬)||pop;
				};
			};
		};
		...labelsof symbols;
		let isPublicByDefault = {};//:#const setting
		let addTraitToType(traitInstance,typeObj)=>{//
			let i = -1;
			let labels = traitInstance..labels;
			repeat labels..length{
				let name = labels[i+=1];
				let property = traitInstance[""...name];
				let typeObj[¬traitObj][""...name] = property;
				repeat(
					(!!isPublicByDefault && !!property[¬Trait.public]||!property[¬Trait.private])||
					( !isPublicByDefault && !!property[¬Trait.public]&&!property[¬Trait.private])
				):let typeObj[""...name] = property;
				repeat(property[¬Trait.asMethod.meta] != ()):#{
					let typeObj..prototype[""...name];
					let isDefaultMethod = property[¬Trait.asMethod.meta]== ¬;
					repeat !!isDefaultMethod:
						let typeObj[¬traitObj]..prototype[""...name] =
							typeObj..prototype[""...name] <=>
							#(){#return = property(this,...arguments)}
						;
					;
					repeat !isDefaultMethod:
						#typeObj..prototype[""...name] <=> property[¬Trait.asMethod.meta]
					;
				};
				repeat(property[¬Trait.asMethod.asm] != ()):#{
					let typeObj..prototype[""...name];
					let isDefaultMethod = property[¬Trait.asMethod.asm] == ¬;
					meta.if(isDefaultMethod)<:(){
						let typeObj[¬traitObj]..prototype[""...name] =
							typeObj..prototype[""...name] <=>
							#(state,getArguments,getOutputs){
								let s;
								let this[¬s]=derive.method.asm;
								#return = this[¬s](property,this,state,getArguments,getOutputs);
							}::{
								let function = property;
							}
						;
						repeat !property.use let property.use(){
							#property:>static.use();
							#return = property;
						};
					}<:(){
						#typeObj..prototype[""...name] <=> property[¬Trait.asMethod.asm];
					};
				};
			};
		};
		let typeToTrait(typeObj){
			let typeObj[¬Trait] = Trait()<:(type){#return<=>typeObj};
		};
		let impl(typeObj,implData){//:Type 'Type:>Trait.impl((type){let a,b,c;})'
			#return = typeObj;
			repeat(typeObj..length == 0): #typeObj::()={};
			repeat !!implData let traitInstance = implData(typeObj);
			repeat !implData let traitInstance = typeObj;
			let typeObj[¬typeObj];
			let typeObj[¬typeObj]..prototype;
			let typeObj[¬Trait] = Trait(implData)::{
				let .[¬traitNameLabel] = typeObj;
			};
			#addTraitToType(traitInstance,typeObj);
			#addTraitToType(traitInstance..prototype,typeObj..prototype);
		};
	};
	repeat 0 #{
		let ExampleTrait1(type){
			let staticProperty1{//'type.staticProperty1'
				print("Hello, world!");
				@return;
			}::{};
			let ..prototype{
				let property1{//'type().property1'
					let value;
					r0 = value;
					@call property;
				};
			};
			let method1(object,arg1,arg2){//'type.method1(type(),4,5)'
				object.value<->object.value + arg1*arg2;
				#return = object;
			}::{let .[¬Trait.asMethod.meta]};//'type().method1(4,5)'
		}:>Trait();
		let type()={
		}:> ExampleTrait1();
		type().method1();
	};
	let Type = #(){
		let Type<=>Trait()<:(type){//similar to Trait, but for objects
			repeat !type.[¬alreadyCalled] #type::()={
				repeat !..this[¬type]
					#let ..this[¬type]{...labelsof this},..this[¬Type.symbols.type] = type;
			};
			let type.[¬alreadyCalled];
		}¬::{
			let addType(obj,type){
				#return = obj;
				#let obj[¬type];
			};
			//enum: [¬Template],[¬Type],[¬Known]
			let isType(type){//:(#{})->#{}?
				#return = type[¬Type];
			};
			let isInstance(type){//:(#{})->#{}?
				#return = type[¬Type.symbols.type]];
			};
			let symbols;
			let symbols.type;
		};
		let alreadyCalled;//:symbol
		#return = Type;
	}();
	let Known:>Type();//an object that is not an owned template, prevents Pointer mutating this
	let ToType<=>Trait()<:(type){
		let set toType(object,castType){//:castType
			#return = toType[¬castType](object)
				||castType[¬ToType].fromType[¬type](object,type)
				||{throw "cannot convert types"}
			;
		}::{let .[¬Trait.asMethod.meta]};
		let set fromType(object,castType){//:type
			#return = fromType[¬castType](object)
				||castType[¬ToType].toType[¬type](object,type)
				||{throw "cannot convert types"}
			;
		}::{let .[¬Trait.asMethod.meta]};
	};
	let Wrapper<=>Trait()<:(type,innerType){
		let innerType = innerType||¬;
		let unwrap(){
			#delete this[¬type];
		};
	}¬::{
		let Wrap(type,innerType){//:Trait ; includes Wrapper trait
			#return = Wrapper(type)::(innerObject)={
				#{
					let object = ..this;
					#wrap(object,innerType()||innerObject,type);
				};
			};
		};
		let wrap(wraperObj,wrapeeObj,type){//:#<W=Wrapper,T>(obj:~W<T>,T,Type<T>?)->mutate obj:W<T>
			#return = wraperObj;
			let type = type||wraperObj..constructor;
			#let set wraperObj[¬type]::{
				...labelsof wraperObj;
			};
			meta.if(wraperObj.wraperObj == ())<:(){
				#wraperObj::{
					...labelsof wrapeeObj;
				};
			}<:(){
				#wraperObj..splice(-0,0,{wrapeeObj});
				#wraperObj::{
					...labelsof ..splice(-1,1)[0];
				};
			};
			#wraperObj..proto = {}::{
				let set:..super = wrapeeObj..proto;
				let set:..proto = wraperObj..proto;
			};
		};
		let ..prototype{
			let unwrap(){
				#this
			};
		};
	};
	let Struct<=>Trait()<:(type){//:Trait<()->[]ram>
	}¬::{
		let Struct = ..this;
		let Object(object)={//:{@}&any
			//any object, of any size
			//Is userally stored on the heap, but can also be stored on static,regs,stack etc...
			...codeof object;
		}:>Struct():>Wrapper.Wrap();
		let Container(object)={//:<T>(T)->~T ;
			//A container contains an object that is yet to be initialised.
			//Note, using type annotation '~' for the more general container type
				//Read as 'approximately'. e.g. '{let a = ¬} : #~{a:#int}'
			//May not contain a valid object of type.
			//Can be used for @ constructors
			//e.g.
				//Calling @malloc returns a Container,
				//Then calling a @constructor will turn the container into a valid Object
			...codeof object;
		}:>Struct():>Wrapper.Wrap():>Trait.impl()<:(type){
			let new(object){//constructor trait, #(Container)->
				#return = object[¬Container[¬Trait]].new()||return;
			}::{let .[Trait.asMethod.meta]=¬};
		}¬::{
			//the container trait is put on objects to construct them
			let .[¬Trait] = Trait()<:(template_or_type,constructor_){
				let new;//:#()-> @(Container<T>)-> T
				#{
					meta.if(!!constructor_)<:(){
						#new = constructor_;
					}<:(){
						meta.if(!!Type.isType(template_or_type))<:(){
							let type = template_or_type;
							#new::{let .[¬Trait.asMethod.asm]};//:#<T>(T)-> @(Container(T))->T
						}<:(){
							let template = template_or_type;
							#new(){
								let i = -1;
								let codeList = this..@;
								repeat codeList..length:...codeof{
									[this+(+i)] = codeList.(i+=1);
								};
							};
						};
					};
				};
			};
		};
		repeat 0 #{:example;
			Container({1;2;3}:>Container[¬Trait]()).new;
		};
		#Heap:>Trait.impl()<:(type){
			let fill(object,value,tempReg){
				let reg = RegEnum();
				mask = value;
				meta.if(object[¬Static])<:(){
					meta.forEach(object..@)<:(v,i){
						[v] = value;
					};
				}<:(){//assert: object:%[]heap
					let heapObject = heap.Object();
					let size <-> tempReg;
					%size = [%obj-(-heapObject.next)];
					%size -= %object;
					jump->return..return if == 0;
					for.doFor(size,(i){},(continue){jump->continue if!=0},(i){%i-=1})<:(i){
						[%object+%i] = value;
					}
				};
				mask = 0;
			}::{let .[¬Trait.asMethod.meta] = ¬;};
		};
		delete Struct;
	};
	let Pointer(typeOrObject,isType)={//(T|Type<T>,()|{}):T*
		let ..this[¬..constructor];
		...codeof{
			let type,object;
			#isType = isType || Type.isType(typeOrObject);
			meta.if(!!isType)<:(){//%T*
				#type = typeOrObject;
				#object = type();
			}<:(){//@T*|%T*
				#object = typeOrObject;
				#type = object..constructor;
			};
			#..this[¬..constructor]={
				let size = object..@..length;
				let data = object;
				let type = object..constructor;
			}::{
				#..proto = pointer..prototype;
			};
			@((object<->0)||0);
			#..this::{...labelsof ..this[¬..constructor];};
			#..this::{...labelsof (object)::{#..compile};};
			let ..this..proto = {}::{
				let ..super = object..proto;
				let ..proto = pointer..prototype;
			};
		};
	}:>Type():>Wrapper()::{
		let isPointer(label){
			#return = label[¬Pointer]||¬;
		};
	};
	let OuterType<=>Trait()<:(type){//type of wrapper, %|{@}
		#type::()={
			let .[¬OuterType] = ..constructor;
		};
		#let set:set;
		#let set:clone;
	};
	let Index(onObject,propertyIndex)={//:#<P:O+ & #[]O?, O:{@}>(P?,O?)-> O+P ; '@[%object+property]' | '@%object+=property
		...codeof propertyIndex;
		let set .[¬constructor]{
			let object = onObject;
			let property = propertyIndex;
		};
		...labelsof .[¬constructor];
		#Wrapper.wrap(this,propertyIndex);
	}:>OuterType():>Wrapper();
	let Item(onObject,property)={//:#<P:[]O,O:{@}>(P?,O?)-> []O
		...codeof property;
		let set .[¬constructor]{
			let object = onObject;
			let property = property;
		};
		...labelsof .[¬constructor];
		#Wrapper.wrap(this,property);
	}:>OuterType():>Wrapper();
	...labelsof Struct;
	let usize(value)={def value||¬0};//:Type<unsigned @>
	let int(value)={def value||¬0};//:Type<@>
	let Optional(noneObject,someType)={//:#(value,Type)->Optional
		let None,Some;
		let None = #(){
			#return <=> noneObject;
			let return[¬None];
		};
		let Some = #(value){
			#value = value || {0};
			#return = value;
			let value[¬Some];
			let value.[¬someType]{value};
		}:>Wrapper();
	}:>Type():>Trait.impl()<:(type){
		let set None, Some;
	};
	let NullableReference:>Type()::()={
		#return = Pointer(...arguments);
		let return[¬NullableReference];
	}:>Optional[¬Trait](Pointer)::{
		let None(){
			return = Pointer():>Type.addType(NullableReference)::{
				let value = 0;
			};
		}:>Type();
		let Some(obj){
			return = Pointer(obj):>Type.addType(NullableReference);
		}:>Type();
	};
	let Function<=>Trait()<:(function,inputTypes,returnTypes){//{@}
		let inputs<=>inputTypes||{};
		let outputs<=>returnTypes||{};
		let regsUsed;
		let use = #(state){
			#:static.use(this);
		};	
		let call = #(){
			#function.use();
		};
		let reg = RegEnum();
	};
	let Method<=>Trait()<:(function,inputTypes,returnTypes){//{@}
		#function:>Function(inputTypes,returnTypes);
		let inputs{
			def let self;//
			...codeof labelsof inputTypes;
		};
		let outputs{
			def let self = inputs.self;
			...codeof labelsof returnTypes;
		};
		let regsUsed;
		let type[¬Trait.asMethod.asm] = ¬;
		let use = #(){
			;
		};	
		let call = #(){
			;
		};
		let reg = RegEnum();
	};
	let Allocator<=>Trait()<:(type){
		let alloc;//#(self)->{@} & self:(Container|Object)&[]type
		let free;//#(self)->{@}
		let New;//:#(type)->type; generates a new memory area of this allocator type
	};
	let StaticData = Allocator():>Trait.impl()<:(type){//#()->unallocated []static
		let Static;
		let free(label){
			undef label;
			#return = label;
		}::{let .[Trait.asMethod.meta] = ¬;};
		#use::(label){
			;
		}::{let .[Trait.asMethod.meta] = ¬;};
	}:>Allocator():>Wrapper.Wrap():>Type();
	let Stack(){
		;
	}:>Allocator():>Wrapper.Wrap():>Type():>Trait.impl()<:(type){
		#alloc(label){//#<T>(%Container(T))->{@(%)->Container(T)}
			meta.if(!!label[¬Container])<:(){
				sp -= label..@..length;
			}<:(){
				def meta.forEach(label..@,(v,i){push i});
			};
			repeat(+label!=0) %label = r0;
			//repeat !label[¬Container]:label..constructor[¬Constructor](label);
		}::{
			let .[Trait.asMethod.meta] = ¬;
		};
		#free(label){
			meta.if(!!label[¬Container])<:(){
				sp -= label..@..length;
			}<:(){
				def meta.forEach(label..@,(v,i){push i});
			};
		};
	};
	let Heap(){//#()->unallocated []heap
		#this<=>this...heap.Object();
	}:>Allocator():>Wrapper.Wrap():>Type():>Trait.impl()<:(type){
		#let alloc(label){//#<T>(%Container(T))->{@(%)->Container(T)}
			r0 = (label[¬Pointer].size||label..@..length);
			heap.malloc.use();
			repeat(+label!=0) %label = r0;
			//repeat !label[¬Container]:label..constructor[¬Constructor](label);
		}::{
			let .[Trait.asMethod.meta] = ¬;
		};
		#let free(heapObject){//#()->{@(%[]heap)->mutate heap}
			repeat(+label!=0) r0 = %heapObject;
			heap.free.use();
			//repeat !label[¬Container]:label..constructor[¬Constructor](label);
		}::{
			let .[Trait.asMethod.meta] = ¬;
		};
	};
	let Register:>Allocator()::(contains,register)={
		repeat !!register: ..this <-> register;
		let set .[¬..constructor]{
			let register = register;
		};
	}:>OuterType():>Type():>Wrapper.Wrap():>Trait.impl()<:(type){//:#<T>(T)-> %T; %register
		let:set(label1,label2){
			meta.unimplemented();
			meta.if(!!label2[¬Register])<:(){
				%label1 = %label2;//`% = %`
			}<:meta.if(!!label2[¬Static])<:(){
				%label1 = [label2];//`% = [@]`
			}<:(){
				%label1 = label2;//`% = #`
			};
		}::{let .[¬Trait.asMethod.meta] = ¬;};
		let:set_deref(label1,label2){
			meta.unimplemented();
			meta.if(!!label2[¬Register])<:(){//`% = [%]`
				%label1 = [%label2];
			}<:meta.if(!!label2[¬Static])<:(){//`% = [[@]]`
				%label1 = [label2];
				%label1 = [%label1];
			}<:(){//`% = #`
				%label1 = [label2];
			};
		}::{let .[¬Trait.asMethod.meta] = ¬;};
		let:deref_set(label1,label2,tempReg){//(%*,%,%?)->{@} & {@mutate *%}
			meta.unimplemented();
			meta.if(!!label2[¬Register])<:(){//`% = [%]`
				[%label1] = %label2;
			}<:meta.if(!!label2[¬Static]||!!label2[¬Struct])<:(){//`% = [[@]]`
				[%label1] = label2;
			}<:(){//`% = #`
				meta.if(!!tempReg)<:(){
					push [label2];
					[%label1] = pop;
				}<:(){
					%tempReg = [label2];
					[%label1] = %tempReg;
				};
			};
		}::{let .[¬Trait.asMethod.meta] = ¬;};
	};
};
...labelsof{
	let DynLenObjectPtr(data)={//:{@[l]*,@l,@(>=l)} ; object with dynamic size
		def let slice = constructor.Slice(data)||{
			#def let data<=>NullableReference(data||Object);//:@any*?
			#def let size<=>usize(0);//:@usize
		};
		#Wrapper.wrap(this,slice);
		def let capacity<=>usize(0);//:@usize
	}:>Type():>Trait.impl((type){
		//remember: data must be a pointer otherwise all refs will have to be updated whenever the data is realloced
		let meta_set(label,data){
			#return = label;
			#return.data <=> Pointer(data,());
			#return.size <=> usize(data..@..length);
			#return.capacity <=> usize(data..@..length);
		}::{let .[¬Trait.asMethod.meta]=¬};
		let push{//:@(%(self&DynLenObjectPtr)*,ref:%@*)->([%ref]: %(@self*?)*) & mutate self
			let static = Static();
			let reg = RegEnum();
			let regsUsed;
			let inputs = {
				def let self = reg()<=>Pointer()<:DynLenObjectPtr();//:%DynLenObjectPtr*
				def let size = reg()<=>usize();//:%usize
			};
			let outputs = {
				def let self = inputs.self;
				def let newItem = +inputs.size <=> Pointer(Container);//%@[size]* & %([]*dynArray.data)
			};
			{:pushFunction;
				let self = inputs.self;
				let temp = reg();
				let temp2 = reg();
				#reg = RegEnum(0xmin.Math.max(heap.resize.regsUsed,heap.malloc.regsUsed,heap.free.regsUsed));
				let store = {
					let self = reg()<=>outputs.self;

					let newSize = reg()<=>usize();
				};
				{:sizeCheck;
					:handleCapacity;
					let newSize <-> inputs.size;//share
					meta.assert(+outputs.newItem == +inputs.size);
					//assume: %outputs.newItem == %inputs.size
					%newSize += [%self + self.size];
					%newSize - [%self + self.capacity];
					if <= 0 !signed jump -> {:returner;
						let temp = temp;
						%temp = [%self + self.size];
						[%self + self.size] = %newSize;
						%outputs.newItem = %temp;
						%outputs.newItem += [%self + self.data];
						return;
					}:>static.use();
					%store.self = %self;
					%store.newSize = %newSize;
					{:growArray;
						%newSize <<= 1;
						[%self + self.capacity] = %newSize;
						repeat (+newSize != 1): r1 = %newSize;
						r0 = [%self + self.data];
						let successfulResize;
						if == 0 jump -> static.use()<:{:handleNullDataPointer;
							r0 = %newSize;
							call heap.malloc;
							[%store.self + store.self.data] = r0;
							jump -> successfulResize;
						};//handle null
						let newSize = ¬;
						call heap.resize;
						if !sign jump -> successfulResize::{
							%outputs.self = %store.self;
							let self = outputs.self;
							%temp = [%self + self.size];
							[%self + self.size] = %store.newSize;
							%outputs.newItem = %temp;
							%outputs.newItem += [%self + self.data];
							return;
						};
						{
							r0 = [%store.self + store.self.capacity];
							call heap.malloc;
							let newArray = Pointer(self.data..constructor)<->heap.malloc.outputs[0];//%Object* & %[]heap
							let reg = RegEnum(1);
							let oldArray = Pointer(self.data..constructor)<->reg();
							%oldArray = [%store.self + store.self.data];
							{:moveArray;
								#reg<->2;
								reg.weakScope()<:(){
									for.doFor(reg())
										<:(i)=>{
											%i = [%store.self + store.self.size];
											%i -= 1;
											if == 0 jump->return..return;
										}<:(i,continue){if >= 0 jump->continue;}
										<:(i){%i -= 1;}
									<:(i){
										let item <-> temp2;
										%item = [%oldArray + %i];
										[%newArray + %i] = %item;
									};
								};
								//assert: newArray:%DynLenObjectPtr().data*
							};
							[%store.self + store.self.data] = %newArray;
							r0 = %oldArray;
							call heap.free;
						};
						def successfulResize;
					};
				};
			};
			#reg<->reg.max;
			def static.memory;
			#regsUsed = reg;
		}::{
			let use(state){
				#{
					let tempLabel = ..this.static;
					delete ..this.static;
					#:static.use(..this);
					let ..this.static = tempLabel;
					delete tempLabel;
				};
				#heap.malloc.use();
				#heap.free.use();
				#heap.resize.use();
				#return = ..this;
			};
			let .[¬Trait.asMethod.asm](newItem,pushFunction,state,getInputs,getOutputs){
				def let block = RegEnum(this.regsUsed).blockScope(2)<:(reg)=>{
					let isNumber = #((0+newItem)==(0+newItem))&&!(newItem..constructor||newItem[¬Static]||newItem[¬Pointer]);
					#newItem = newItem || {0};
					meta.if(!!+Pointer.isPointer(this))
						<:(){%inputs.self = %this}
						<:(){%inputs.self = this}
					;
					repeat !newItem throw "method 'DynLenObjectPtr.push' requires an object";
					%inputs.size = #((+isNumber&&newItem) || (newItem[¬Pointer].size||newItem..@..length));
					call ..this.use();
					def pushFunction(newItem,isNumber)||meta.if(!+isNumber)<:(){
						let item = newItem..@;
						meta.forEach(item)<:(v,i,a){
							[%outputs.newItem] = v;
							%outputs.newItem += 1;
						};
						%outputs.newItem -= item..length;
					};//#(%[]array*,{@})->{@}
				};
				#block::{
					repeat !!getInputs {
						#meta.if(!getOutputs)<:(){
							push<=>{sp-=push..length};
						}<:(){
							undef push;
						};
						def getInputs(state,this,return,2);//2 inputs
					};
					repeat !!getOutputs {
						#meta.if(!getInputs)<:(){
							pop<=>{sp+=pop..length};
						}<:(){
							undef pop;
						};
						def getOutputs(state,this,return,2);//2 outputs
					};
				};
				delete block;
			};
		}:>static();
		let pop{
			let .[¬Trait.asMethod.asm] = ¬;
			let use(state){#;
				#return = ..this;
				#static.use(..this);
				#heap.shift.use();
			};
			let regsUsed;
			let reg = RegEnum();
			let inputs{
				let self = Pointer():>DynLenObjectPtr()<->reg();
				let size = int()<->reg();
			};
			let outputs{
				let self = Pointer():>DynLenObjectPtr()<->reg();
			};
			{:block;
				let end = block..return;
				...labelsof inputs;
				[%self+self.size] -= %size;
				let case_sizeIsEmpty;
				if <= 0 !signed jump -> case_sizeIs0;
				def case_sizeIsEmpty{
					[%self+self.data]|0;//if None
					jump -> end if == 0;
					return;
				};
			};
			return;
			#regsUsed <-> reg;
		};
	});
	let DynLenObjectPtr.Slice()={//:{@[l]*,@l}
		def let data<=>NullableReference(Object);//:@any*?
		def let size<=>usize(0);//:@usize
	}:>Type():>Trait.impl((type){
		let meta_set(label,data){
			#return = label;
			#return.data <=> Pointer(data,());
			#return.size <=> usize(data..@..length);
		}::{let .[¬Trait.asMethod.meta]=¬};
		let printString = {//:@(self:%*)->mutate terminal
			let regsUsed = 0;
			let reg = RegEnum();
			let inputs = {
				def let self = Pointer()<:DynLenObjectPtr.Slice()<->reg();
			};
			let outputs = {
				def let self = inputs.self;
			};
			{
				:block;
				...labelsof inputs;
				let const_0 = reg();
				let array_end = Pointer() <-> reg();
				%const_0 = 0;
				%array_end = [%self + self.data];
				for.doFor(reg(),(i){
					%i = [%self + self.size];
					jump->block..return if == 0;//!signed
					%array_end += %i;
				},(i,to){
					jump->to if > 0 !signed;
				},(i){%i-=1})<:(i){
					send %const_0 [%array_end - %i];
				};
				#block<=>reg.blockScope(1,(reg){...codeof labelsof block});
			};
			return;
		}::{
			let .[¬Trait.asMethod.asm] = ¬;
		};
		let printArrayObject = {//prints array data
			let used(){
				#return = this:>static.use();
			};
			let inputs{
				def let self = Pointer()<:DynLenObjectPtr.Slice()<->0;
			};
			let outputs{
				def let self = inputs.self;
			};
			...labelsof inputs;
			def let intPrinter = {
				let reg = RegEnum();
				let obj = reg();
				let size = reg();
				%size = [%self+self.size];
				%obj = [%self+self.data];
				let const_0 = reg();
				print("@",const_0);
				#let const_0.is0 = 1;
				print.register(obj,const_0);
				print(":",const_0,{});
				print.register(size,const_0);
				print("{",const_0,{});
				let temp = {repeat 2 reg()};
				{:forLoop;
					let max = size;
					//max:%int !signed & []
					let i = temp[0];//:%obj+ !signed
					%max|0;
					jump->forLoop..return if==0;//"{}"
					%i = 0;
					def let loop;
					{:do;
						let v = temp[1];//:%[]obj
						%v = [%obj+%i];
						%v &= 0xff;
						print.number.hexChar(v,const_0);
					};
					%i+=1;
					%i-%max;
					jump->forLoop..return if==0;
					{:onLoop;
						print(",",const_0,{});
					};
					jump->loop;
				};
				print("}\n");
			}:>(a){(){a}}():>reg.blockScope();
			let regsUsed = 0;
		}::{
			let .[¬Trait.asMethod.asm] = ¬;
		};
		let print = printArrayObject;
		let fill{
			let .[¬Trait.asMethod.asm] = ¬;
			let use(state){#;
				#return = ..this;
				#static.use(..this);
			};
			let regsUsed;
			let reg = RegEnum();
			let inputs{
				def let self=Pointer(type())<->reg();
				def let value=usize()<->reg();
			};
			let outputs{
				def let self=inputs.self;
			};
			...labelsof inputs;
			${:block;
				let i = reg();
				let data = Object()<->reg();
				%i = [%self+self.size];
				%data = [%self+self.data];
				jump->block..return if == 0;
				for.doFor(i,(){},(continue){if>=0 jump->continue},(){i-=1})<:(){
					[%data+%i]=value;
				}
			}:>(a){(){a}}():>reg.blockScope({self});
			return;
			#regsUsed <-> 0;
		};
	});
	#DynLenObjectPtr:>Trait.impl()<:(type){
		let printArrayObject = Slice.printArrayObject;
		let printString = Slice.printString;
	};
	let ArraySlice(templateObject,items)={
		#this<=>constructor.fromType[¬DynLenObjectPtr.Slice](DynLenObjectPtr.Slice(),typeTemplate);
	}:>Type():>ToType()::{
		#let fromType[¬DynLenObjectPtr.Slice](slice,typeTemplate){
			#return = ArraySlice()::{
				def let array = slice;
				let item{
					let template = typeTemplate;
					let size = typeTemplate..@..length;
				};
				#Wrapper.wrap(return,array);
			};
		};
	}¬:>Trait.impl()<:(type){
		#let meta_set = DynLenObjectPtr.meta_set;
		#let push = DynLenObjectPtr.push;
	};
	let RefList()={
		#return = RefList.OwnedSource();
	}:>Type():>Trait.impl()<:(type){//for many to one a->b<-c
		//RefList is a type of smart pointer,
		let RefObject()={//:Type{([]source&{@}*)*,source:OwnedSource,@any}
			let data;
			def let itemRef <=> Pointer()<:Item(OwnedSource().refs)<:Pointer()::{#object=data};
			def let owner <=> Pointer(self);
			def data <=> Object();
		}:>Type();
		let OwnedSource()={//:Type<:DynLenObjectPtr<:Ref*[]
			def let refs <=> DynLenObjectPtr();//:DynArray<owned<*>>
			#Wrapper.wrap(this,refs);
			let [¬OwnedSource]{...labelsof this};
		}:>Type():>Trait.impl()<:(type){
			let mallocRef{
				let .[¬Trait.asMethod.asm](objectToRef){
					RegEnum(..this.regsUsed).blockScope()<:(reg)=>{
						def meta.if(Pointer.isPointer(this))<:(){
							r0 = %this;
						}<:(){
							r0 = this;
						};
						repeat !!objectToRef meta.if(!!objectToRef..constructor)<:(){
							r1 = objectToRef..@..length;
						}<:(){
							r1 = objectToRef;
						};
						call ..this.use();
					}::{#pop..splice(-2,2)};
				};
				let mainBlock;
				let use(state){#;
					#return = ..this;
					#:static.use(..this);
					#:static.use(heap.malloc);
					#:static.use(DynLenObjectPtr.push.use());
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{
					def let self = Pointer(OwnedSource())<->reg();
					def let size = usize()<->reg();
				};
				let outputs{
					def let self = Pointer(OwnedSource())<->0;
					def let newItem = Pointer(RefObject().data)<->1;
				};
				{
					let newRef <=> Pointer()<:Container()<:RefObject();
					#newRef<->heap.malloc.outputs[0];
					#let temp_self <-> RegEnum(heap.malloc.regsUsed)();
					#let refSize = RefObject()..@..length;
					{:malloc;
						%temp_self = %inputs.self;
						r0 = %inputs.size;
						r0 += refSize;
						call heap.malloc;
						[%newRef+newRef.owner] = %temp_self;
					};
					let ref;
					{:push;
						#let reg = RegEnum(DynLenObjectPtr.push.regsUsed);
						#let storeTemp{repeat 1 reg()};
						#let storeTemp.ref = ref = #({}<=>newRef)<->storeTemp[0];
						@: %storeTemp.ref = %newRef;
						@: %DynLenObjectPtr.push.inputs.self = %temp_self;
						@: %DynLenObjectPtr.push.inputs.size = 1;
						@: call DynLenObjectPtr.push;
						#meta.assert(+outputs.self==+DynLenObjectPtr.push.outputs.self);
						@: [%DynLenObjectPtr.push.outputs.newItem] = %storeTemp.ref;
						@: [%storeTemp.ref+storeTemp.ref.itemRef] = %DynLenObjectPtr.push.outputs.newItem;
					};
					%outputs.newItem = %ref;
					%outputs.newItem += ref.data;
				};
				return;
				#regsUsed <-> 0xmin.max(heap.malloc.regsUsed,DynLenObjectPtr.push.regsUsed);
			};
			let unref{//:@(%,%)->(%,fail:flag(sign?))
				let .[¬Trait.asMethod.asm] = ¬;
				let know_isValid;//for calling unref on refs that are known to be valid.
				let use(state){#;
					#return = ..this;
					#:static.use(..this);
					#:heap.free.use();
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{
					def let self = Pointer(OwnedSource())<->reg();
					def let ref = Pointer(RefObject())<->reg();
				};
				let outputs{let self = inputs.self};
				let static = Static();
				{
					...labelsof inputs;
					reg.weakScope()<:(reg){:validateRef;
						let fail{
							r0 | -1;
							return;
						}:>static.use();
						let item <-> reg();
						{
							#item <=> Pointer()<:Item(self.data,RefObject());//:%RefObject&[](OwnedSource().data&RefObject[])
							%item = [%ref+ref.itemRef];
							%ref - [%item];
							if != 0 jump -> fail;
						};
						let index <-> item;
						#index <=> usize();
						{
							%index -= [%self+self.data];
							if < 0 !signed jump -> fail;//assert:index>=0
							%index - [%self+self.size];
							if >= 0 !signed jump -> fail;//assert:index<self.size
							//assert: ref is in bounds
						};
						#regsUsed<->reg;
					};
					def know_isValid;
					let itemRef <-> reg();
					#itemRef <=> ref.itemRef;
					%itemRef = [%ref+ref.itemRef];
					let endItem <-> reg();
					#endItem <=> Pointer(RefObject());
					{:get_endItem;
						%endItem = [%self+self.data];
						%endItem += [%self+self.size];
						%endItem -= 1;
						%endItem = [%endItem];
					};
					[%itemRef] = %endItem;
					{:updatePointers;
						[%endItem+endItem.itemRef] = %itemRef;
					};
					%self_temp = %self;
					call heap.free %ref;
					%self = %self_temp;
				};
				r0|0;//success
				return;
				def static;
				#regsUsed<->0xmin.Math.max(regsUsed,reg);
			};
			let unrefAll{
				let .[¬Trait.asMethod.asm] = ¬;
				let use(state){#;
					#return = ..this;
					#:static.use(..this);
					#:heap.free.use();
					#:unrefRef.use();
				};
				let regsUsed;
				let reg = RegEnum();
				let inputs{def let self = Pointer()<:OwnedSource()<->reg()};
				let outputs{def let self = inputs.self};
				let reg1 = RegEnum(heap.free.regsUsed);
				...labelsof inputs;
				{push %inputs.self;
					let array<->reg1();
					#array<=>self.data;
					%array = [%self+self.data];
					{:loop;
						let ref = RefObject()<->reg();
						for.doFor(reg1()<=>usize(),
							(i){
								%i = [%self+self.refs.size];
								%i -= 1;
								jump->loop..return if <= 0 !signed;
							},
							(i,continue){jump->continue if >= 0 !signed},
							(i){%i-=1}
						)<:(i){
							%ref = [%array+%i];
							{:dropReference;
								r0 = [r ref-1];
								heap.unref(ref,unrefRef,{});
							};
						};
						//heap.unref(self,unrefRef,{});
					};
					def let resizeArray{
						...labelsof inputs;
						repeat 0: ...{:drop;
							r0 = %array;
							call heap.free;
						};
						repeat 0: ...{:shrink;
							#use::(){
								#heap.resize.use();
							};
							call heap.resize;
							#regsUsed <-> heap.resize.regsUsed;
						};
					};
				pop %inputs.self};
				[%self+self.size] = 0;
				return;
				#regsUsed <-> 0xmin.Max(regsUsed,reg,reg1);
			};
			let unrefRef{
				let use(state){#;
					#:static.use(..this);
				};
			};
		};
	}¬::{
	};
	let printObject{//:@(%)->mutate
		let reg = RegEnum();
		let inputs{
			def let obj = heap.Object.pointer=() <-> 0;
		};
		let outputs{};
		let doOnUse(foo){
			#list..splice(-0,0,{()=>{#return{foo}}});
		}::{let list};
		//almost same code as DynLenObjectPtr.Slice.printArrayObject
		def:{
			let obj = heap.Object.pointer=()<->reg();
			let size = reg();//:%sizeOf obj.data
			%size = [%obj-(-obj.next)];
			%size -= %obj;
			let const_0 = reg();
			print("@",const_0);
			#let const_0.is0 = 1;
			doOnUse()<:(){print.register(obj,const_0);};
			print(":",const_0,{});
			doOnUse()<:(){print.register(size,const_0);};
			print("{",const_0,{});
			let temp = {repeat 2 reg()};
			{:forLoop;
				let max = size;
				//max:%int !signed & []
				let i = temp[0];//:%obj+ !signed
				%max|0;
				jump->forLoop..return if==0;//"{}"
				%i = 0;
				def let loop;
				{:do;
					let v = temp[1];//:%[]obj
					%v = [%obj+%i];
					print.number.hexChar(v,const_0);
				};
				%i+=1;
				%i-%max;
				jump->forLoop..return if==0;
				{:onLoop;
					print(",",const_0,{});
				};
				jump->loop;
			};
			print("}\n");
		}:>(a){(){a}}():>reg.blockScope();
		return;
		let use(){
			#return = ..this;
			#..this[¬Static].use();
			#meta.forEach(doOnUse.list,(v){v()});
		};
		let regsUsed = 0;
	}:>static();
	#heap.Object:>Trait.impl()<:(type){
		let print<=>printObject;
		#print::{
			let [¬Trait.asMethod.asm] = ¬;
		};
	};
	let StoredProcess()={
		def let state{
			def let registers{
				repeat 14 0;
				def let stackIndex{0};
				def let stack <=> DynLenObjectPtr();	
			};
		};
		def let objects = Process();
	}:>Type()<:Trait.impl()<:(type){
		let alloc(self){//new
			#meta.assert(!!Pointer.isPointer(self));
			%heap.malloc.inputs.(0) = self..@..length;
			call heap.malloc.use();
			%self = %heap.malloc.outputs.(0);
		}::{let .[¬Trait.asMethod.meta]};
		let save(self){
			let reg = RegEnum();
			#meta.assert(!!Pointer.isPointer(self));
			let stored{
				def let self{0};//:Self*
				def let stack{0};
			}:>static.use();
			[stored.self] = %self;
			[stored.stack] = sp;
			RegEnum().weakScope()<:(reg){:saveStack;
				let _self = Pointer(StoredProcess)<->reg();
				%_self = %self;
				let self = _self;
				delete _self;
				let array = Index(self,self.state.registers.stack);
				{
					[%self+array.size] = 0;
					%self+=array;
					(DynLenObjectPtr()<->self).push();
					meta.unimplemented();
				};
				for.doFor(reg(),
					(i)=>{
						%i = sp;
						jump->return..return if == 0;
					},
					(i,do){jump->do if !=0},
					(i){i+=1}
				)<:(i){
					[%self+self.state]
				};
			};
			[%self+self.state.registers.stack] = sp;
			sp = %self;
			meta.assert(+self.state.registers == 0);
			meta.repeat(14,(i){
				[self_stored]
			})
		}::{let .[¬Trait.asMethod.meta]};
	};
	let Process()={//type
		def let ownedObjects<=>RefList.OwnedSource(Process);
		//def let weakReferences<=>RefList.WeakSource(Process);
		//def let objectReferences<=>RefList(Object);
		def let references{0};//Process*[]*
		def let ownedStaticObjects{0};//
	}:>Type():>StoredProcess[¬Trait]();
	let LenObject(_size,_object)={
		def let size <=> usize();
		def let object <=> Object();
		#:set(_size,_object);
	}:>Type():>Trait.impl()<:(type){
		let: meta_set(lenObject,len,object){
			#lenObject.size[0]=len||object..@..length;
			#lenObject.object<=>{object};
		}::{let .[¬Trait.asMethod.meta];};
	};
};
let LenString(string){//{@;char[l]}
	#return = LenObject().meta_set((),string):>static.use();
};
let String(string){//dynamic string; :{@char[l]*;@l;@}
	let stringObj = heap.Object(string):>static.use().data[0];
	#return = DynLenObjectPtr().meta_set(stringObj):>static.use();
	let return.print = return.printString;
};
let str(string){//string slice
	let stringObj = heap.Object(string):>static.use().data;
	#return = DynLenObjectPtr().meta_set(stringObj).slice:>static.use();
};
repeat 0 {:example;
	let string = "Hello, world":>static.use().data;
	let list = DynLenObjectPtr().meta_set(string):>static.use();
	list.print();
	list.push("!");
	print("\n");
	list.print();
	def static.memory;
	def heap.data;
};
#String().print();