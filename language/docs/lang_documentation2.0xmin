//meta keywords list declarators and definers #
#def;
#set;
#let;
#var;
//special meta statements
if(){}
else if(){}
else{}
delete;
import;
static;
debugger;
recur;
repeat(){}
//weak scopeing keywords/symbols
@;
$;
#;
void;
// not implemented special statements
void;
//assembly key words
move;
jump;
nor;
red;
blue;
get;
set;
if;

//assignment
=;
=>;
<=>;
->;
<->;
//maths operators
( + - * / ** % );
//bitewise operators
( | & ^ ~ );
//logical operators
( ! || 	&& ^^ );
( == != > < >= <=);
//1 or 2 argument operators
( + ); //(a+b) or cast to number 
( ~ ); //(a nor b)

//scopes
//let scopes aka block scopes
{} 
//weak blocks
${} #{} void{} if(){}
//labeled blocks (with break and continue)
a:{} 
//weak blocks
$a:{} #a:{} void a:{}
//var scopes. aka object scope (with this and return)
a{}
//function types
(){} ()={} ()=>{}
//extension scopes
::{} ::#{} ::${} ::void{}


//keyword property names
//labels (memory pointer)
//object
this;
return;
//labeled block
break;
continue;
//class instance
constructor;
//property used in classes
prototype;

//inbuilt global objects
0xmin;
Number;
String;
true;
false;
null;
undefined;
if;
else;
debugger;
repeat;
//const properties
String.col;
String.pos;
String.confirm;

//computer's:pointers and registers
jump;
move;
alu;

// not implemented features
use; //e.g. use(x,y,0xmin){can only use the arguments}
0xmin.Object;
new;
#{
	instructions{//the block is also a label
		//create labels
			#let myLabel;//create a label with unlabeled-block-scope 
			#let myLabel;//over right the label with a new one at the same scope.
			#var myLabel;//create a label with labeled-block-scope similar to "this.mylabel;"
		//labels MUST be defined with "def" for them to be used by the following.
		//pointer control
			move -1;//move the data pointer (the pointer is named "move") back 1 step
			jump -> myLabel;//(i.e. "goto" in c++) move the jump pointer to the location of "myLabel"
		//ALU operations. for operator `X(a,b)`, the CPU does `X(accumilator,*move)`
			nor;//logical NOR
			red;//variable_red_shift
			blue;//variable_blue_shift(B)
			get;//read to accumilator
			//new commands
			xor;
			and;
			or;
			get jump;//(aka get jump-1;)reads filt from the last jump address. if jumped to from somewhere else: will get a different value.
		//Other commands
			set;//write from accumilator ("set;" is aka "set move;" or "set move+0;")
			if;//if(one of the previous ALU operations was successful i.e didn't = 0)reset the boolean register to false;else ignore the next line.
			set jump;//sets a filt relative to jump. e.g. "set jump+2"; the "+2" is a constant that depends on hardware so will through an error if this is wrong.
	}		
	1213;//can put numbers instead of keyword instructions
	0b10110;//30 bit number
	0x3fffffff;
	0x123 def instructions.myLabel;//def sets a label's address to the current line
	#let labelName,lbl2;//"#" the meta symbol. lines of code and blocks with "#" arn't included in the .filt file
	1 def labelName,lbl2;//
	jump +2;//jump forward 2 lines
	move -4;//move data_pointer back 4 lines
	move->labelName;//move the data_pointer to labelName
	jump->labelName;
}
scope_types{
	@{} ${} #{} void{} if(1){}//weak scopes
	{} a:{}//let scopes aka block scopes
	let a{}//var scopes. objects
	a:{} $a:{} #a:{} void a:{}//
	let a(){} let a()={} let a()=>{}//functions
	a::{} a::#{} a::${} a::void{}//extension scope
}
function_calls{
	//e.g. with foo
	let foo(){
		;
	}

	foo();//normal call. uses the function's type.
	foo=();//call as class.
	foo=>();//call as arrow function.
	foo{};//function call with block
	foo(){}
}

aBlockLabel{//blocks can be labeled like this
	123 def let a;//can also chains meta keywords like this.
	move->a;
};

all_scope_types:{
	//blocks;
		let bar {};
		let {};
		{};
		let bar : {};
		let : {};
		: {};
		:: let bar {};
		:: let {};
		:: {};
		:: let bar : {};
		:: let : {};
		:: : {};
		:: bar {};
		:: bar : {};
		bar : {};
	//function
		let bar () {};
		let () {};
		() {};
		let bar : () {};
		let : () {};
		: () {};
		:: let bar () {};
		:: let () {};
		:: () {};
		:: let bar : () {};
		:: let : () {};
		:: : () {};
		bar : () {};
		:: bar () {};
		:: bar : () {};
	//function call
		bar () {};
		bar {};
		let bar ();
		bar ();
	//simple label
		let bar;
		bar;
	//eval bracket
		let ();
		();
		;
}

//#let bar : () {};
//keyword label symbol bracket block
// /bracket (?!block)/ = evalBrackets
// /bracket block/ = parameters
//"label (equality_symbol)? bracket" = arguments

non_bracket_programming:{
	//using 0xmin without: "{}" including OOP, blocks and functions.
	//instead of weak_scopes use "#;"s changes the phase level of the scope
		#; //meta, macro's
		$; //hidden assembly direction
		@; //plain assembly
	//instead of block scope, use "delete;"
	#let i;
	0 def i;
	#delete i;//"i" cannot be used beyond this point.
}
# let className() = {
	constructor;
	# var property;
} :: {
	# var set prototype {
	}
	# var set supertype {
	}
	# var staticProperty;
}