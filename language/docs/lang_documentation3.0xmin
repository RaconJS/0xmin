//comment
/*multi line comment*/
#"0xmin";
//keywords
	#void;
	#static;//static is not used yet
	#virtual;
	#recur;
	#repeat;
	#delete;
	#throw;
	#import;
	#import lib;
	#import this;
	#import main;
	#...let;
	#...set;
	#...def;
	#...labelsof;
	#...codeof;
	#...run;
	#let;
	#set;
	#def;
	$undef;
	$def;
	$set;
	$jump;
	$move;
	$ram;
	$alu;//unused
	@move;
	@jump;
	@set;
	@if;
	@nor;
	@red;
	@blue;
	@and;
	@or;
	@xor;
	@or input;
	@get jump -1;
	@set jump +3;
//words that can't be used for variables

	//[there are none]
//symbols
	@ $ #
	+ - * / ** % ^ & ~ ¬
	! ^^ || &&
	= <=> <->//assignment operator
	-> <- => <=//$/@ assembly operator
	=> = -> <- <=//function types
	:> <: //pipeLineing/external arguments
	... //concat
	:: //extend object or function
	( ) [ ] { } //brackets: expression '()', index '[]', code block '{}'
	"" '' ``; //multi-line strings
//defenite brackets
	#() #[] #{} //normal meta-expression brackets. The '#' is normally highlighted as white to indicate this.
//function delcarations
`note: can also do`#(){}`to avoid confusion with`foo = (){}` => `(foo=())#{}` or `foo = #(){}` => `foo = #((){})``
	(){}//defualt function
	#(){}
	()={}//class
	#()={}//etc... can put '#' infront of a shortExpression to separate it from others
	()=>{}//block scope function (aka arrow function)
	()<={}//strong scope function. Is like a sandbox
	()->{}//weak scope function
	()<-{}//macro scope function (aka macro/injection function)
//function extensions for existing variables
	foo (){}
	foo::(){}
	foo ()={}
	foo::()={}//etc... can put '::' to make extention functions/object more explicit visually
	foo ()=>{}
	foo ()<={}
	foo ()->{}
	foo ()<-{}
//function calls
	foo()
	foo=()
	foo=>()
	foo<=()
	foo->()
	foo<-()
	foo(a,b,c,{...d},e,f)//can pass in objects/functions as arguments as well
	foo(a,b) <:c <:{...d} <:e <:f //same function call, just with some external arguments
	a:> b:> foo(c,{...d}) <:e <:f //using pipelining operators
	foo(bar(baz)); /*or*/ bar(baz):>foo() /*or*/ foo()<:bar(baz)
//object declarations
	{}
	#{}
//object extensions
	obj{}
	obj::{}
//@ / $ expressions
	//number can be any of: 123, +123,-123,*123,/123
	label;
	label +123;
	label label;
	label -> +123;
	label -> label;
	label label -> +123;
	label label -> label;
//line structure
//formal
@ $ # void virtual static://start of line
	recur: 2 //allows for this line to be run 2 times
		@ $ #//choses phase to start at.
		repeat: 3
			repeat: 4//3 * 4 = 12 iterations
				://assembly,hidden,meta phases: have to be done in that order; starts with the phase chosen previously
					jump label1 => label2//assembly phase; '=>' sets value, '->' just evaluates it.
					$undef set def://hidden/secret phase;
						label from => to
					#let set def://meta phase; '#def: x;' == '$undef def set: x;'
						label=foo({})+4
					delete label1, label2
					delete //remove all labels from this scope
					throw "error message";
					debugger (label+4) "label.labels";
					import this "fileName.0xmin"
					import lib "libraryName.0xmin"
					import main "fileName.0xmin"
					... let set def labelsof codeof run://inject code, similar to import and object extending
;
@ $ # void virtual static recur repeat//start of line
//note: ':'s,'@$#'s are optional but are recomended as a best practice.
//Phases symbols can be infered, prioritising the '@' phase over '#' where possible.
//It is highly recommended to use phase symbols for consistancy.
://':' can be used to allow keywords to be seen as variable names
//e.g.
	#let: let=2;//makes a variable called 'let';
//instead of
	#let let;//which does nothing; 

//change the default phase
	@; $; #;
{//e.g.
	#;//void #;
	let a;//#let: a;
	a=2;//#set: a = 2;
	@;//void @;
	a;//@a;
}//the default phase affects the nearest scope (weak scope).

{//basics
	//0xmin compatibillity version 3
	//aka 0xmin V3;
	0xmin 3;
	//aka ZASM
	ZASM;
	//aka 0xmin Assembly Small Macro language
	//aka 0@$#;
	0@$#;
	//0xmin is a C-like language. i.e. '//' == comment, {} == block of code
	//is more similar to javascript in terms of flexibility
	//zasm uses
	{};//everything even block scopes MUST end with a ';'.
	{1;2}//The only exeption is at the last line of code
};
0xmin;{//machine code
	//can write numbers
	0x123;
	123;
	0b1001;
	//can instead use number arguments for assembly code.
	//0xmin uses the form:
	//instuction(4bit) relativeAddress(8bit) sign(1bit)
	//e.g.
	//jump -5;//note: singed numbers are not yet supported can use 'jump -> label instead'
	//can be writen as a list of assembly parts:
	//in order: 
	@command address isNegative;
	1 5 1;//=>'jump -5;'=>[jump,5,-]
	1 5 0;//=>'jump +5;'=>[jump,5,+]
	//special charactors
	//char's
	"\p00";//set curser posision
	"\c00";//set curser colour
	"\h";//hault. compiles to 'jump 0;'
	"\a";//accept input from terminal
	"\x00";//ASCII charactor
	"\u0000";//unicode charactor
	//char's compile to: 'print char'
	//strings
	"hello world";
	//compiles to
	"h";"e";"l";"l";"o";" ";"w";"o";"r";"l";"d";
};
@;{//assembly code
	{//basics:
		//commands;
		//pointer commands
			move;jump;
		//misc commands
			set;//writes the accumilator's (aka 'alu') value to the memory under the 'move' pointer
			if;//if an operation did not fail (i.e. would not of had result '0') since the last time the 'if' command was used, then do nothing this cycle; otherwise set the 'if' flag to 0 and run the 'null' command next cycle. aka: 'if' command has the structure: 'condision;if;then;else;'
			
			//special commands
				set jump +3;//writes the 'alu's value to the line 3 ahead of the 'jump' pointer.
				get jump -1;//reads the previous command to the 'alu'. Note that the '-1' is a bit missleading as if the last command was a 'jump 10' command, then it would return that 'jump 10' command even though it is not on the 'x-1'th line.
				or input;//does 'alu=alu|input' where input is the input port (keyboard) from the R216K2A terminal.
	
		//alu commands
			get;nor;red;blue;and;or;xor;
		
		//all commands (exept for the 3 special ones) use this structure
		command address sign;

		//e.g.
		jump 4 0;
		//compiles to:
		1 4 0;
		//compiles to:
		0x0041;
	};
	//can also use 'a to b' aka 'a -> b' syntax
	{
		#let: labelName;//created a variable/label called 'labelName' in the 'meta' ('#') phase;
		$def: labelName->0xmin 5;//then in the memory assignment ('$') phase it sets labelName's memory address to 5;
		//labels can be 
		jump->labelName;//jumps to labelName
		move=>labelName;//moves to labelName
		//'=>' is just like '->' execept at has changes the assosiated pointer compile time
		//so repeating using '->' :
			move->labelName; //move #(+labelName);
			move->labelName; //move #(+labelName);
		//would compile to the same result each time
		//but repeating  using '=>' :
			move=>labelName; //move #(+labelName);
			move=>labelName; //move 0;
		//
		//tip: in general, always use '->' with 'jump', and use '=>' with 'move'
		jump->labelName;move=>labelName;
	};
};
$;{
	$undef:label;//removes all defs of the label.
	$set:label;//assigns the lineNumber of label, or it can run a '$' expression to assign 'label's lineNumber. It can also add a 'def'
	$def:array;//inserts the code of 'array' into the block
};
#;{
	#let set def;//are executed in that order
	#let: label;/*creates a label. Can add this to the local block scope e.g.*/ let label=0; /* or to an existing object e.g.*/ let object.label=0;
	//if a label exists it will replace it. labels can not be created through expressions like in javascript*/
	//i.e. labels must be created using `let`
	/*e.g.*/#set: object.newProperty=2;/*will not do anything*/
	/*technically*/
		#let:/*takes in as arguments: a single expression, followed by a long expression. The short expression becomes the 1st argument in the long expression e.g.*/let (["short"..."expression"]) * long + expression;
		/*. This is then used for the new label.*/
		special cases:
			//case 1
			{let a = a + 2} -> {let b=a+2;let a=b;delete b}:
				/*If the next symbol is*/ = /*then it creates the label after the long expression.*/
				/*e.g.*/let a=a+1;
				/*Other wise it creates the label before evaluating the long expression.*/
				/*e.g.*/let a::{def let a.b=2;};
			//case 2
			{def let a:>foo()} -> {let a;#set a:>foo();def a;}:
				/*:> is ignored in the first short expression. This is to allow type conversions.*/
				/*e.g.*/let a :> float(2);
				/*here we make a 'float' with value '2' called 'a'. In this example float is an existing function that takes in two arguments*/
			//case 3
			{let=a,=b,=c} -> {let a=a,b=b,c=c}:
				//for hoisting variables into a new scope
	//----
	#let set: label;//creates a new label only if it does not already exist in this block scope.
	#let set: label.property;//only creates a new property if it does not exist.
	#let set: a=b;//'let set' can be used for expressions just like and '#' operator

	#set:// is used for assigning values to existing labels.
	/*e.g*/#let: label;#set:label=2;
	/*note: because*/ #def: /*also can be used to assign values,*/#def set:/*is exactly the same as*/#def:
	/*combinind 'let' and 'set' has its own special case as shown previously.
	intended use:
	#let: a;
	#set: a=2;
	#def: a;
	#set: 1 + 2 * 4;//evaluates an expression operators are done in order exept for the assignment operators: '=', '<=>' and '<->'
	#def: label;/*inserts label into the scope's code array;*/

	/*note: at the moment:*/ #def:label; /*is syntactic sugar for:*/ $undef: label;$set: label;$def: label;//in that order except it only inserts one line into the block instead of three
	/*the */#def/*(just like the 3:*/$undef set def:/*), applies the to the final value, meaning:*/#def: foo();/*is the same as:*/#let: bar=foo();#def: bar;
	expressions;(
		//value types:
		1,//number
		"string",//string
		label,//label,
		,//array: not used
	);
	
	infered syntax:
		/*the '#' in*/#let #set #def/*can be infered as long it is not a keyword in the assembly language. i.e in #"0xmin"; you can use*/let x=2;def x;/*instead of*/#let:x=2;#def:x;
		//e.g.
		let label=2;/*is syntactic sugar for:*/#let:label=2;
		
		//the colon ':' is only needed if the next word would be a keyword but should be parsed as a label, otherwise the ":" can infered.
		//e.g.
		let set def label;/*is the same as*/#let set def: label;/*which is also the same as*/#let set: label;#def:label;
		/*More generally: this sort of infrence applies to all parts of this programming language, and not just for*/#let set def;
		//in this document we have tried to use the more explicit syntax where possible to reduce confusion.
		
		foo()/*if a word (regex/\b\w+\b/), that is not a keyword: then it will default to*/$:foo();/*which defaults to*/$let set def: foo();
		//this is usefull for including functions calls that look the same as in most C-like programming languages
};
starter line:{
	void;{//OUT_OF_DATE
		does not add this line of code to the parent scope_object;
		usefull for mutating arrays without leaving a trace;
		note: it is pointless to use '$' and '@' type code on void lines as they cannot be found in the assembly/hidden phases.
		//lets say we want an #array with 4 items and a property pointing to the last one
		example1
		let array5{
			1;
			2;
			3;
			let item4=0;//this line is included in the array //update: this is not included
			4 #def item 4;
		};//array5..length=5
		example2
		let array4{
			1;
			2;
			3;
			void let item4=0;//this line is NOT included in the array
			4 #def item 4;
		};//array4..length=4
	};
	static;{
		not supported yet; might allow running code in function scopes.
	};
	//to ensure that Macros always hault, maximum recursion and iteration must be stated.
	repeat;{
		//allows for iteration.
		repeat single_expression:lineOfCode;//Runs the line:'lineOfCode' 'expression' times.
		e.g.
		repeat 10:foo();
		/*The expression just after the 'repeat' keyword is evaluated every iteration,
			but the maximum iterations allowed can only be reduced. This is so breaking is possible
		*/
		
		//repeat can be used to generate long arrays
		e.g.
		let longArrayOf1s={repeat 100:@1;};
		
		//example of repeat.
		#def let: array={
			let i=0;
			repeat (10-(i+=1)):
				#def: i;
			;
		};/*results with the array: {1;2;3;4;5;6}*/

		inferance;
			the colon ":" is not needed but can be used in some cases to stop the statement and the expression from merging.
			e.g.
			repeat 10: (1+1);//colon is needed here for clearness
			repeat 10 jump +3;//colon is not needed here
	};
	recur;{
		recur//Allows for the use of recursion.
		recur expression:lineOfCode;
		//note: Recursion is only allowed by using the recur statement. This is to prevent it from being turing complete
		example1{
			let foo(){
				recur 10: foo();//
			};
		}
		example2{
			let foo(){
				recur 10 #foo()...foo();//the 'recur 10' applies to the rest of the line of code after it so both 'foo()'s will be called ~10 times
			};
		}
		by default every line of code is the same as
		repeat 1 recur 1:...doStuff;
	}
};
import;{
	//import opens a file and runs it in the current scope
	//use form
	import lib "libraryFile.0xmin";//imports a standard library. aka the include folder
	import this "subFile.0xmin";//imports relative to the current file
	import main "projectFile.0xmin";//import relative to the first file.
	import "file.0xmin";//default setting: 'import "";' ==> 'import this "";' 
};
...;{
	...//injects parts of a label into the current scope's label (scope.label)
	...let: {let a,b,c;};...let object;...labelsof;//properties (namespace)
	...set: {1;2;3;};...set array;...codeof;//code (array)
	...def: (){1;2;3};...def function;...run;//runs code in scope. Can act the same as 'import'.
	//these can be combined;
	... let set def: label;
	//default
	... label; /*is the same as*/ ...let set def: label;
};
delete;{
	removes properties from an object.
	delete;//delete all labels in block scope
	delete label;//deletes label from 
	intended use:{
		#let:bar;
		#def:bar;
		move=>bar;
		delete bar;
		//ensures that 'bar' cannot be used beyond this point
	}
};
virtual;{
	code inside a virtual line acts like normal code with a few differences that affects the $ and @ phase;
	assembly inside virtual is not included in the final binary file. At the end of the virtual line, the cpu state is reset to how it was before the line;
	allows for running code in different places;
	used for struct pointers;
	e.g.:{
		let SomeStructure(){
			def let char2;
			"ab";
			def let intA;
			1;
			def let intB;
			4;
		};
		let pointer=SomeStructure=();
		virtual def pointer;
		def let someCode{//some code with the same structure as 
			"a";"b";
			1;2;
		};
		//We want 'pointer' and it's properties to have the same cpuStates as 'someCode'
		//without using 'virtual' we could use ..compile() and 
	};
};
//design notes:
//function code is imutable
//cpuState checking
{//e.g.
	$move=>0xmin;
	jump -> 2;//throws a cpuState error as move is not the same on lines 2 and 4
	move +2; //move => move+2;
	null;
}
{!jump -> 2;
	//can use '@: !command;' to ignore state checking
	//can use '!jump' or '!move'
	//'!command;' can be used for variables/constants e.g. can be used (in the 0xmin-emulator) to store return addresses in assembly function calls
	{//example of use
		$jump=> a;
		$jump->b;//state check a->b
		$jump=> 0;
		!jump a->b;
	};
	{//e.g. without '!'
		$move=>0xmin;
		jump -> 2;//The state checker throws an error Error: 'cpuState miss-match'.
		move +2; //move => move+2;
		null;
	};
	{//e.g. with '!' command
		$move=>0xmin;
		!jump -> 2;//ignores state checking and compiles as normal 'jump -> 2'
		move +2; //move => move+2;
		null;
	};
	{//the '!' command can also be used with the 'move' command so it doesn't change the cpuState.
		//e.g.
		$move=>0xmin;
		jump -> 2;
		!move +2;//doesn't change the move pointer so does not throw an error.
		null;
	};
	{//In practice the '!' modifyer is normally used to store commands as a variables, as it can do this without changing cpuState
		//e.g.
		jump 2;
		def let jump10Lines = {!jump 10};
		move=>jump10Lines;get;
		move=>2;set;
		null;//:jump command used here
	}
};
$set:foo->bar;//'->', aka the `to` operator, returns 'bar - foo'.
$set:move=>label;//'=>', aka the `set to` operator, is similar to '->' exept it sets the memory location of  foo to bar, at ($) compile time
move 2;/*is the same as:*/move=>move 2;
move=>move 2;/*is the same as:*/move->move 2;$set:move=>move 2;
move->move 2;//does not change

code blocks;{
	a codeBlock is made using curly brackets;
	The global scope is similar to a inbuilt code block;
	e.g. { ...doStuff; } //
	It contains a list of assembly instructions for the assignment ('$') and assembly ('@') phases of compilation;
	when parsed in the metacode phase:
		It is turned into a list of numbers (aka 0 code), assembly code (aka @ code), functions (aka # code),and compiler code(aka $ code).
	Code blocks can be named. This can be useful for referenceing a block within itself, while keeping it self contained.
	e.g.
	{	
		{:block;
			{
				let block.b=2;
			};
			jump b;
		};
	};
	This naming syntax can also be useful for making loops
	e.g.
	{
		#def:{:blockName;//note that blocks are not assigned memory locations by default. 
			...doStuff;
			jump->blockName;//without the '#def' this would through an $error.
		};
	};
	Using named blocks without #def can be usefull for making multi-dimentional arrays. 
	e.g.
	{
		let matrix={
			{1;0;0};
			{0;1;0};
			{0;0;1}
		};
		let twoMatrixies={
			matrix;
			matrix
		};
	};
};
function blocks;{
	//function is made by a pair of normal brackets '()' followed by an optional function type =,=>,<=,<-,-> followed by curly brackets '{}'. the normal brackets contain a list of parameters.
	//All parameters and special function variables, like return and this, are stored in a scope inbetween the function instance and the parent scope of the function.
	//e.g.
		let Foo = #(a,b)={a;b};
		
		//Here we make a 'Foo' class. In this context the '=' symbol is what makes it a class.
		//It is not important here but this function returns an array with 2 items in it.
		//The '#' stops the compiler from doing 'Foo=()'.
		//We can also do:
	//e.g.
		let Foo(a,b)={a;b};
		//For more consise syntax; This 2nd example is slightly different than the first one in what it does.
	//e.g.
		let foo(a,b){a;b};

	//by default functions return the code block.
	//this can be changed by assigning a value to the inbuilt 'return' label.

	//note:
		#let a = #(){};
		//is exactly the same as
		#let a;#let a[0] = #(){};
	//When you call an object (aka a label), all the functions and objects inside the array part are called.
	//each function uses it's own parameters but they all share the same arguments, return value and function instance object.
	//e.g.
		let bar = {(a){a};(b,c){b;c}};
		def bar(1,2);
		//gives the same result as
		let bar = {(a,b){a;a;b}};
		bar(1,2);
		//gives the same result as
		let bar = {{{(a){a}}};(b,c){b;c}};
		def bar(1,2);
	
	{//function variables
		#(){
			scope;//macro only
			return;
			arguments;//the list of arguments provided, as well as containing a namespace for the aguments.
			constructor;//is the original function;
			this;//same as this in javascript, except if the function is called without a parent (i.e. 'foo()' instead of 'bar.foo()') then then it returns the var scope where the function was origionally made.
			//If the function type is a class then this returns the new function instance.
			caller;
		};
		//these labels refer to 
		//e.g.
			{
				let 
					varScope,
					blockScope,
					callerScope,
					ownerObject,
					otherFoo,
					foo
				;
				#varScope{
					{
						:block;
						#blockScope = block;
						#foo(){
							let 
								scope = scope,
								return = return,
								arguments = arguments,
								constructor = constructor,
								this = this,
								caller = caller,
								__this = ..this
						};
					};
				};
				#ownerObject{
					let method_foo = foo;
				};
				#otherFoo = foo;
				//note: all things done with foo will have the exact same results with otherFoo, except from debug label naming.
				let callerVarScope{
					let callerBlockScope = {
						:self;
						#callerScope = self;
						delete self;
						//note: '¬()' is the 'null' label
						#baz = foo(1,2,3);
							#baz.scope;//¬()
							#baz.return;//baz
							#baz.arguments;//{1;2;3}
							#baz.constructor;//the global object
							#baz.caller;//callerScope
							#baz.this;//callerVarScope
							#baz.__this;//varScope
							//note:
								//If a function type is set, then 'foo()' will use the function type specified in it's delcaration.
								//e.g. 'foo=()' overrides the function type with '=', which turns it into a class.
						#baz = ownerObject.method_foo(1,2,3);
							#baz.scope;//¬()
							#baz.return;//baz
							#baz.arguments;//{1;2;3}
							#baz.constructor;//the global object
							#baz.caller;//callerScope
							#baz.this;//ownerObject
							#baz.__this;//varScope
						//note: in general:'a.b()' gives same result as 'b()' except 'this':
							//The 'this' label refers to the object it was the property of.
							//This is the same similar to the 'this' keyword in javascript.
						#baz = foo=(1,2,3);//called as a class
							#baz.scope;//¬()
							#baz.return;//baz
							#baz.arguments;//{1;2;3}
							#baz.constructor;//foo
							#baz.caller;//¬()
							#baz.this;//baz //this stays the same even if called as a method
							#baz.__this;//baz
						#baz = ownerObject.method_foo=(1,2,3);
							#baz.this;//baz
							//the rest are the same
						#baz = foo=>(1,2,3);//called as an arrow function
							#baz.scope;//¬()
							#baz.return;//¬()
							#baz.arguments;//¬()
							#baz.constructor;//¬()
							#baz.caller;//¬()
							#baz.__this;//varScope
						#baz = foo->(1,2,3);//called as a weak scoped function.
							#baz.scope;//¬()
							#baz.return;//¬()
							#baz.arguments;//¬()
							#baz.constructor;//¬()
							#baz.caller;//¬()
							#baz.__this;//varScope
							//same as foo() except that 'let x' would assign to 'blockScope' instead of the function instance
						#baz = foo<-(1,2,3);//called as a macro
							#callerScope.scope;//callerScope
							#callerScope.return;//baz
							#callerScope.arguments;//{1;2;3}
							#callerScope.constructor;//the global scope
							#callerScope.caller;//callerScope
							#callerScope.__this;//callerVarScope
							//description of general idea & use of marcos e.g. 'foo<-()':
								//macro 'foo<-()' functions: are similar to '...foo' except with more tools to modify the scope that calls the function
									//Their code is run almost directly in the scope, similar to '...foo' but they still have access to 'foo..prototype'. and 'foo..supertype' aswell as any arguments
									//They can reference the caller scope so they can modify it.
								//labels in macros are assigned to the scope they were called from, instead of where they were defined
						#baz = foo<=(1,2,3);//called as a strong scoped function.
							#baz.scope;//¬()
							#baz.return;//¬()
							#baz.arguments;//¬()
							#baz.constructor;//¬()
							#baz.caller;//¬()
							#baz.__this;//baz
							//Labels defined outside of this function cannot be accessed.
							//It is intended for:
								//easier to read code,
								//making functions more pure functions code
								//providing a sandbox to run and test functions that mutate parent scopes
						//note: e.g. 'foo<=(x,y,z)' aka 'foo() but only using x,y, and z'
					};
				}
			}
		//the 'midScope'
			//Function instances contain a hidden scope sandwiched inbetween the function's parent scope and the function instance
			//This hidden scope is called the 'midScope' in the compiler.
			//It contains all the inbuilt variables such as the arguments, 'constructor' 'this' 'arguments' etc...
			//A polly fill for what function calls look like under the hood might look like
			//e.g.
				let foo{
					let parameterNames = {let a,b,c};
					let code = (a,b){
						#return = a + b;
					};
				};
				:globalObject;
				let foo.call(args,thisObject)->{
					let .[arguments] = args;
					let .[caller] = caller;
					let .[this] = thisObject;
					...labelsof args;
					let .[return]{
						...foo.code;
					};
					#let returnValue = .[return];
					#delete .[return];
					#return = returnValue;
				};
	};
};
single_expressions;{
	expressions can have the form:
	+!~ (long_expression) .a.b()()[4]..length()<:a<:b;
	single argument operators are included in expressions as well as indexing and function calls.
	datatypes;{
		symbol;{
			casting: ¬x ; //converts value into a symbol value.
			//this type acts like a normal label except, when it is used as an array index '[¬x]', it turnes a private property.
		}
		label;{
			casting: ¬ x ; //converts value into a symbol which acts the same as a label
			//tip: labels can be thought of as similar to the Javascript Object type.
			casting from;{
				//polly fills for type casts
				let numberToLabel(number){
					#return = {};
					#return :: {
						#..constructor = 0xmin.Number;
					};
					#return <-> number;
				};
			}
			//UNFINISHED
		}
		string;{
			casting: (""...x) ;
			casting_decimalNumber: (""...+x);
		}
		number;{
			casting: +x or !x;
			bitewise operators can be used for casting aswell;
			note that booleans have the number datatype so doing !!x will cast a truthy value to 1 and a falsy value to 0;
			!!label returns 1 if the label exists;
			!!+label returns 1 if the labels number value is not 0;
		}
		array;{
			casting: can not cast to array;
			array is a poorly supported type.
			It is mainly used in: debugger object..labels;
		};
	}
	internal properties;{
		Every label has internal properties;
		Accessing them calls an inbuilt javascript function;
		Some internal properties return inbuilt functions that are bonded to the label;
		full list:
		label..length;//returns a number type
		label..code;
		label..splice(a,b,c);//takes in 1 indexes, how many to remove, and an array label object. e.g. a..splice(1,2,{1;2;3});
		label..array;
		label..labels;//returns list of all the properties in an object (ignoring symbol properties)
		label..compile;//returns a MachineCode object, converted into a label. 
		label..seal;
		label..freeze;//returns a key that can be used to unfreeze the label. a frozen label's properties, number and code etc... cannot be changed. note that it only freezes 1 layer deep.
		label..this;//returns the label itself. '..this' is usefull when used like javascript's `this`. e.g. 'let obj{let addBar(){let ..this.bar=2;}}'
		label..return;//returns an inbuil label that is defaultly defined at the end of the parent label. e.g. def let block{jump->block..return;...doStuff;}
		label..proto;//if label does not contain a property, then the compiler looks for the property in label..proto
		label..super;//similar to proto except looked for first when finding a property
		label..constructor;//Returns the class '()={}' (if any) that was used to construct this label.
		label..prototype;//used in class calls i.e. 'class=()' as 'class..prototype'. 'class=()..proto == class..prototype'
		label..supertype;//similar to 'label..prototype' but for supertypes
		label..defs;//returns an array of all the places where
		label..indexOf(item);//similar to indexOf in javascript
		label..asNumber;//converts to number and returns a number type
		label..state;//returns the label's CpuState (from the start of the label). the ..state contains it's own properties.
		label..state.move;//the data pointer's state. This property was disigned for 0xmin assembly but can be used in any assembly
		label..state.jump;//the instruction pointer's state.
		label..state.ram;//the memory location. ..ram is not as usefull. It is easier to use 'jump->label' instead of 'jump->label..state.ram'
		label..flat;//returns a 1D array,can be used to get a list of all the objects in a graph, can also be used to get all the source-code of a function
	};
};
long_expressions;{
	pipeLine;{#;
		':>' operator
		e.g.
		let foo(a,b,c){
			;
		};
		let a,b,c;
		a:>b:>foo(c);
		special case:
			as described in the #let section, if the pipeline just after the first symbol in a let statement then it will be p
			e.g.
			#let a:>foo() is parsed at #let a;#set a:>foo();
		intended uses:
			//foo1:(a,b)->x; foo2:(x,c)->y
			foo1(a,b):>c:>foo2();
			{let a:>Vector3(3,4,5);}
		examples
			let foo,bar,baz,a;
			1;
				#foo() <: a:>bar();
				//same as
				#foo()<:(a:>bar());
				//same as
				#foo(bar(a))
				//this is because a:>bar() is a single expression and pipelines look for single expressions.
			2;
				#foo()<:bar()<:baz()<:a;
				//same as
				#foo()<:(bar()<:(baz()<:a));
				//same as
				#foo(bar(baz(a)));
			3;
				#foo():>bar():>baz()<:a;
				//same as
				#((foo()):>bar()):>baz()<:a
				//same as
				#baz(bar(foo()),a);
	};
	objectExtending using ::;{
		'::' operator
		#let: foo(a,b,c){
			...doStuff;
		};
		#set: foo :: (){
			...doMoreStuff;
		} :: (){
			...doEvenMoreStuff;
		} :: {
			...staticProperties;
		};
		used to concatnate objects '{}' or add a function block '(){}';
	};
	objectAssigning;{
		'{...}' and '(...)...{...}' operators
		You can assign the contense of a variable by adding an object or function expression after it.
		e.g.
		let doStuff(){};
		let foo(arg1,arg2)=>{...doStuff};//function
		let bar{...doStuff};
		let baz;
		baz{...doStuff};
		At the moment they act exactly the same as the '::' operator.
		The only difference is that it cannot be done with the syntax '{}{}'. This allows for '{{}{}}' to be parsed as '{{};{}}'
		{//e.g.
			let bar{#bar = 2};
			Note that in  the 'bar' label is created before the block '{}' is parsed meaning 'bar' can be referenced inside the block.
			In this case 'bar' will have the value '2' by the end of the let statement.
		};
	}
	brackets;{
		Can use: () {} [] aswell as #() #{} #[];
		The '#' (aka the meta) symbol can be put infront of a bracket in a long or short expression to distinguish it from function syntax
		e.g. a = (2+2) ;
		In line above we call the function 'a' as a class with the argument 4.
		e.g. a = #(2+2);
		In line above we assign 4 to the variable 'a'.
		In assembly scopes (@). the #(...) can be used to run meta code inbetween assembly lines.
		e.g. in tptasm: {
			r0 = #(4*3);//compiles to: mov r0 12
		}
		e.g. #(1,2,3)//TODO: decide what this syntax should do
		In lists of values like the line above, the last value will be returned, i.e. 3.
	};
	{:operators;
		operator ¬;{
			the ¬ can be used in 2 ways depending on number of argumments.
			1:
				'label cast / property key'
				¬x turns a value into a label with the 'symbol' value-subtype.
				This can be used to make private variables that can only be accessed by curtain parts of the code
				{:intended use;
					e.g.
					let a;
					{
						let symbol;
						#a[¬symbol]=2;
						let a.returnSymbol(){
							#return = +a[¬symbol];
						}
					};
				};
				
				This can also be used to convert a value into a label.
				e.g.
				{
					let a = #(¬(2+2))[0];
				}
			2:
				'collect and then'
				In a long expresstion, if there are statements behind the ¬, ¬ will be interpretted as the collecter operator:
				This collecter operator gets the current long expression value makes it the start of a short expression.
				It is intended to be syntactic sugar for putting '()'s around a long expresstion
				e.g.
				a + b * c ¬.d
				is the same as: ( (a + b * c).d )
				e.g.
				a + b * c ¬()
				is the same as: ( (a + b * c)() )
				a + b * c ¬ + 2
				is the same as: ( (a + b * c) + 2 )//this would be the same as (a+b*c+2) and ((a+b)*c+2) because of how 0xmin proceedence works
		};
		boolean operators && || ^^;{
			'||' or;{
				Evaluates both arguents first. Then, returns the first value if it is "truthy", and the second if it is "falsy".
				Note: like javascript '||' returns one of the arguments.
				Note: unlike javascript both arguments will be evaluated even if the fist one is "truthy"
			|| //or: returns the second argument if the first one is falsey
			&& //and: returns the second argument if the first one is truthy
			^^ //xor: returns '0' if both inputs are truthy, other wise acts like '||'
			e.g.
			a ^^ b
		};
		boolean operator 'not' !;{
			returns 0 if a value is "truthy" and 0 if it is "falsy"
		};
		bitewise 'nor' ~;{
			e.g.
			#:(a ~ b)
			is the same as
			#:~(a | b)
			note that ~a is still bitewise not
			e.g.
			#:a & ~ b ~ c
			is the same as
			#:(a) & ( ~((~ b) | c) )
		};
		assignment operators = <=> <->;{
			//UNFINISHED: TODO: check this entire section on all 3 assignment types
			= 'assignment';{
				Replaces the label with a new label.
				//this is very similar to assignment in JavaScript with objects
			};
			<=> 'contence assignment';{
				<=> Replaces the contence of a label without changing any label references.
				Can be used for assiging instances of a class to a label while keeping its lineNumber.
				label <=> newLabel;
				
				All properties except for the number value (+label) and any references or (label..defs) are coppied from the value being assigned.
				This includes values accessed with:{
					a . b;
					a .. b;
					a [b];
				};
				This does not replace:{

				}
				e.g.{
					let a = {1;2;3;let foo,bar};
					let b = {2;4;6;let foo};
					def a;
					#a<=>b;

				}
			};
			<-> 'number assignment';{
				Reassigns the numeric value of a label.
				let a = {let prop = 3} <-> 2;
				#+a;// 2
				let b <-> 4;
				a<->b;
				+a;// 4
				a.prop;// 3
			}
		}
		concatnation operator ...;{
			In long expressions this is parsed as a concatnation or spread operator.
			1. concatnation: a...b
				Here it joins the array-like contence of both arguments together, returning a new value/label.
				If the first argument is a label of a string the result will be of that type.
				This means that the following can be used to cast a value to a string
					""...bar //string cast
				;
				¬a...¬b       ==> {...codeof ¬a, ¬b};
				¬a...(""...b) ==> ¬a...¬(""...b);
				""...¬b       ==> ""...¬{...codeof ¬b};
				""...+b       ==> ""...¬{@+b};
				""...¬b       ==> ""...¬{...codeof ¬b};
				""...+b       ==> ""...¬{@+b};
				To turn a number into a decimal string use `..asNumber`
				Note this is one way of returning a non-symbol label
			2. spread operator ...a
				e.g. 
					let add = (a,b){
						#return<->a+b;
					};
					add(...{2;3});
				note since this is part of a long expression:
					doing: (foo()<:...a) will not work.
		}
	};
	proceedence{
		priorities{//from highest to lowest
			1: . //dot operator and function calls
			2: single argument operators including e.g. (+a) (-a) (*a) (/a) !a (¬a) (~a)
			3: :> <: //e.g. 'a:>foo()<:b' is evaluated in the order 'a,b,foo,foo(a,b)'
			4: all other operators including e.g. :: + - * / ...
			5: ¬ // the 'a+b ¬.c' operator
			6: = <=> <-> <- -> <= => //the last 4 are for in 0xmin assembly
		};
		all of these operators evaluate the left side argument first.
		except for assignment operators (=,<=>,<->) everything has the same priority.
		{//in let statements
			e.g. let .("foo") = 2;
			in #let statements, the name of the label is parsed first
		}
		e.g. a+b*c is parsed as (a+b)*c
		assignment operators are always done last, and have the same priority
		e.g. a+b=c+d=e+f is parsed as  (a) = #(b = #(c))
	};
};
internal language structure;{
	the inbuilt global 0xmin object:{
		properties:
		0xmin.Math;
		//UNFINISHED
		//TODO add feature
		0xmin.class;
		0xmin.class.Number;
		0xmin.class.String;
		0xmin.class.Symbol;
		0xmin.class.AssemblyLine;
		0xmin.class.SyntaxTree;
		//UNFINISHED
	};
	function structure;{
		let a (){};
		//a is stored as an array of functions
		//it is similar to the polly fill
		let a {(){}};
		//UNFINISHED
	};
	statement structure and the syntax tree;{
		//UNFINISHED
	}
	assembly line structure;{
		//UNFINISHED
	};

};
compilation_settings;{
	These include the following:
		#"0xmin";
		#"tptasm";//made for the R216K computer.
		#"int";//basic number assembly language. no pointers or special assembly syntax except for "ram"
		#"table";//prints out a list of the output file, allong with the command name and source code. Is very usefull for debugging your machine code.
		#"len";
		#"code";//
		#"make file";//is true by default can use #"!make file"; if you just want to check that some code would compile.
	At the start of a '.0xmin' file you can add; all the compilation settings.
	You can put comments and white space before and between the compilation settings are fine.
	The compilation settings are parsed after the raw text file has been broken up into a syntax tree.
	This means that you can put white space, comments between the octothwarp '#', the string '""' and the semicolon ';'. Note that the semi-colon is mandatory.
	It is also parsed before the main code is.

	You can also put a "!" at the start of the string to negate the setting. e.g. #"!table"; will not print out a table
	This normally includes the assembly language and what data the compiler should print out when it is done.
};
{//un implemented future potential features
	static;{
		let foo(){
			static ..this.bar=2;
		};
		foo.bar;
		static scopes are always run exactly once.
	};
	types;{
		':' operator;
		'foo : bar' operator would enforce the restriction 'bar' onto 'foo'; //similar to typescript
		where: foo is any Value and bar is a function or just a value;
		syntacticly: foo is a long expression and bar is a expression that matches up to a '¬' or '='
		1+1:2+2 ¬ = 2; compiles to: (((1+1) : (2+2)) ¬) = 2;
		e.g.
		let label:condisions=2;//spl
		can make "type" objects
		e.g.
		let Int(){
			???//not sure how this would work yet
		};
		let foo:Int = 2;
		let bar:Int = "a";//throws error
		//there is an idea of using "£" for type expressions, similar to `#()`
	};
	pipeLine;{//IS_NOW_IMPLEMENTED
		':>' operator
		let foo(a,b,c){
			;
		};
		let a,b,c;
		a:>b:>foo(c);
	};
	objectExtending using ::;{//IS_NOW_IMPLEMENTED
		'::' operator
		#let: foo(a,b,c){
			...doStuff;
		};
		#set: foo :: (){
			...doMoreStuff;
		} :: (){
			...doEvenMoreStuff;
		};
		This can already be done by adding an unnamed function or object at the end of a long expression,
		e.g. in 'foo(){...stuff}' '(){...stuff}' is the extension function, that adds onto the end of the 'foo' object.
		Currently '#obj{...}{...};' can be done to extend an object. This would be changed to '#obj{}::{};'
	};
	0xmin.class type;{
		allow detecting data types.
		e.g.
		let a = 3;
		#a..constructor == 0xmin.class.Number;// true
		let a = {@move 3};
		#a[1] = 3;
		#a[0]..constructor == 0xmin.class.Assembly;// true
		#a[1]..constructor == 0xmin.class.Number;// true
	}
	new,var,const;{
		new, var, const would be an inbuilt version of the Data object;
		{
			#let: Data()={
				#let: varList{};
				#let: constList{};
				#let: var(data){
					#set: varList{
						$def: data;
					};
				};
				#let: const(data){
					#set: constList{
						$def: data;
					};
				};
				#let: new{//:data*
					void #let: var(condision){#;
						#let: item;
						#let: isDone=0;
						repeat: (varList..length&&isDone) {
							find a block of memory that meets the condision;
						};
						return = item;
					};
					void #let: const(data){#;
						insert new.var code but with varlist
					};
				};
			}
		};
		the original documentation mentioned these 3;
		new is a type of $set;
		'var': marks a piece of code or assembly line as variable #(not constant);
		'const': marks a piece of code or assembly line as constant;
		'var' and 'const' add code onto a JS array of free code;
		'new': assigns memory locations;
		new searches through the avalable variableList or constantList and assigns the found memory location
		examples;{
			{
				@const nor;
				@const move=>10;
				@var null;
				let new var: a;
				@move=>10#const;
			};
		};
	};
	hoisting;{//IS_NOW_IMPLEMENTED
		let a = 2;
		let b = 3;
		let object{
			let =a,=b;//same as `let a = a,b = b`
		};
	};
	{
		//match 'label, { }' or 'label ( ){ }' -> 'def let set label {}' / 'let set label (){}'
		object{
			...doStuff;
		};
		//same as 
		def let set object{
			...doStuff;
		};
		//`a{}` is can be used for constructing objects, without using 'let' and 'def'
		let object{
			a{11;22};
			b{33;44};
		};
		let foo{
			subFunction1(){

			};
			subFunction2(){

			};
		};
	};
	..function;{
		The list of functions will be contained inside the ..function object, instead of the code part of a label.
		let foo(){};
		foo..function..length;//1
		foo..length;//0
		..function
	};
	private variables{
		//variables that are not accessable through `a.b` only on in scopes where they were defined
		//private variables are accessable ontop of normal scopes
		let a = {
			priv privateLabel = 2;
			{
				:self;
				debugger privateLabel;//2
				let privateLabel = 1;
				debugger privateLabel;//2
				debugger self.privateLabel;//1
			};
		};
		debugger a.privateLabel;//undefined
	}
};