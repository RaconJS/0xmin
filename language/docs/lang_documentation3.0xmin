//comment
/*multi line comment*/
#"0xmin";
//keywords
	#void;
	#static;//static is not used yet
	#virtual;
	#recur;
	#repeat;
	#delete;
	#throw;
	#import;
	#import lib;
	#import this;
	#import main;
	#...let;
	#...set;
	#...def;
	#...labelsof;
	#...codeof;
	#...run;
	#let;
	#set;
	#def;
	$undef;
	$def;
	$set;
	$jump;
	$move;
	$ram;
	$alu;//unused
	@move;
	@jump;
	@set;
	@if;
	@nor;
	@red;
	@blue;
	@and;
	@or;
	@xor;
	@or input;
	@get jump -1;
	@set jump +3;
//words that can't be used for variables

	//[there are none]
//symbols
	@ $ #
	+ - * / ** % ^ & ~ ¬
	! ^^ || &&
	= <=> <->//assignment operator
	-> <- => <=//$/@ assembly operator
	=> = -> <- <=//function types
	:> <: //pipeLineing/external arguments
	... //concat
	:: //extend object or function
	( ) [ ] { } //brackets
	"" '' ``; //strings
//defenite brackets
	#() #[] #{} //normal meta-expression brackets. The '#' is normally highlighted as white to indicate this.
//function delcarations
`note: can also do`#(){}`to avoid confusion with`foo = (){}` => `(foo=())#{}` or `foo = #(){}` => `foo = #((){})``
	(){}//defualt function
	#(){}
	()={}//class
	#()={}//etc... can put '#' infront of a shortExpression to separate it from others
	()=>{}//block scope function (aka arrow function)
	()<={}//strong scope function. Is like a sandbox
	()->{}//weak scope function
	()<-{}//
//function extensions for existing variables
	foo (){}
	foo::(){}
	foo ()={}
	foo::()={}//etc... can put '::' to make extention functions/object more explicit
	foo ()=>{}
	foo ()<={}
	foo ()->{}
	foo ()<-{}
//function calls
	foo()
	foo=()
	foo=>()
	foo<=()
	foo->()
	foo<-()
	foo(a,b,c,{...d},e,f)//can pass in objects/functions as arguments as well
	foo(a,b) <:c <:{...d} <:e <:f //same function call, just with some external arguments
	a:> b:> foo(c,{...d}) <:e <:f //using pipelining operators
	foo(bar(baz)); /*or*/ bar(baz):>foo()
//object declarations
	{}
	#{}
//object extensions
	obj{}
	obj::{}
//@ / $ expressions
	//number can be any of: +123,-123,*123,/123
	label;
	label +123;
	label label;
	label -> +123;
	label -> label;
	label label -> +123;
	label label -> label;
//line structure
//formal
@ $ # void virtual static://start of line
	recur: 2 //allows for this line to be run 2 times
		@ $ #//choses phase to start at.
		repeat: 3
			repeat: 4//3 * 4 = 12 iterations
				://assembly,hidden,meta phases: have to be done in that order; starts with the phase chosen previously
					jump label1 => label2//assembly phase; '=>' sets value, '->' just evaluates it.
					$undef set def://hidden/secret phase;
						label from => to
					#let set def://meta phase; '#def: x;' == '$undef def set: x;'
						label=foo({})+4
					delete label1, label2
					delete //remove all labels from this scope
					throw "error message";
					debugger (label+4) "label.labels";
					import this "fileName.0xmin"
					import lib "libraryName.0xmin"
					import main "fileName.0xmin"
					... let set def labelsof codeof run://inject code, similar to import and object extending
;
@ $ # void virtual static recur repeat//start of line
//note: ':'s,'@$#'s are optional but are recomended as a best practice.
//Phases symbols can be infered, prioritising the '@' phase over '#' where possible.
//It is highly recommended to use phase symbols for consistancy.
://':' can be used to allow keywords to be seen as variable names
//e.g.
	#let: let=2;//makes a variable called 'let';
//instead of
	#let let;//which does nothing; 

//change the default phase
	@; $; #;
{//e.g.
	#;//void #;
	let a;//#let: a;
	a=2;//#set: a = 2;
	@;//void @;
	a;//@a;
}//the default phase affects the nearest scope (weak scope).

{//basics
	//0xmin compatibillity version 3
	//aka 0xmin V3;
	0xmin 3;
	//aka ZASM
	ZASM;
	//aka 0xmin Assembly Small Macro language
	//aka 0@$#;
	0@$#;
	//0xmin is a C-like language. i.e. '//' == comment, {} == block of code
	//is more similar to javascript in terms of flexibility
	//zasm uses
	{};//everything even block scopes MUST end with a ';'.
	{1;2}//The only exeption is at the last line of code
};
0xmin;{//machine code
	//can write numbers
	0x123;
	123;
	0b1001;
	//can instead use number arguments for assembly code.
	//0xmin uses the form:
	//instuction(4bit) relativeAddress(8bit) sign(1bit)
	//e.g.
	//jump -5;//note: singed numbers are not yet supported can use 'jump -> label instead'
	//can be writen as a list of assembly parts:
	//in order: 
	@command address isNegative;
	1 5 1;//=>'jump -5;'=>[jump,5,-]
	1 5 0;//=>'jump +5;'=>[jump,5,+]
	//special charactors
	//char's
	"\p00";//set curser posision
	"\c00";//set curser colour
	"\h";//hault. compiles to 'jump 0;'
	"\a";//accept input from terminal
	"\x00";//ASCII charactor
	"\u0000";//unicode charactor
	//char's compile to: 'print char'
	//strings
	"hello world";
	//compiles to
	"h";"e";"l";"l";"o";" ";"w";"o";"r";"l";"d";
};
@;{//assembly code
	{//basics:
		//commands;
		//pointer commands
			move;jump;
		//misc commands
			set;//writes the accumilator's (aka 'alu') value to the memory under the 'move' pointer
			if;//if an operation did not fail (i.e. would not of had result '0') since the last time the 'if' command was used, then do nothing this cycle; otherwise set the 'if' flag to 0 and run the 'null' command next cycle. aka: 'if' command has the structure: 'condision;if;then;else;'
			
			//special commands
				set jump +3;//writes the 'alu's value to the line 3 ahead of the 'jump' pointer.
				get jump -1;//reads the previous command to the 'alu'. Note that the '-1' is a bit missleading as if the last command was a 'jump 10' command, then it would return that 'jump 10' command even though it is not on the 'x-1'th line.
				or input;//does 'alu=alu|input' where input is the input port (keyboard) from the R216K2A terminal.
	
		//alu commands
			get;nor;red;blue;and;or;xor;
		
		//all commands (exept for the 3 special ones) use this structure
		command address sign;

		//e.g.
		jump 4 0;
		//compiles to:
		1 4 0;
		//compiles to:
		0x0041;
	};
	//can also use 'a to b' aka 'a -> b' syntax
	{
		#let: labelName;//created a variable/label called 'labelName' in the 'meta' ('#') phase;
		$def: labelName->0xmin 5;//then in the memory assignment ('$') phase it sets labelName's memory address to 5;
		//labels can be 
		jump->labelName;//jumps to labelName
		move=>labelName;//moves to labelName
		//'=>' is just like '->' execept at has changes the assosiated pointer compile time
		//so repeating using '->' :
			move->labelName; //move #(+labelName);
			move->labelName; //move #(+labelName);
		//would compile to the same result each time
		//but repeating  using '=>' :
			move=>labelName; //move #(+labelName);
			move=>labelName; //move 0;
		//
		//tip: in general, always use '->' with 'jump', and use '=>' with 'move'
		jump->labelName;move=>labelName;
	};
};
$;{
	$undef:label;
	$set:label; 
	$def:array;
};
#;{
	#let set def;//are executed in that order
	#let: label;/*creates a label. Can add this to the local block scope e.g.*/ let label=0; /* or to an existing object e.g.*/ let object.label=0;
	//if a label exists it will replace it. labels can not be created through expressions like in javascript*/
	//i.e. labels must be created using `let`
	/*e.g.*/#set: object.newProperty=2;/*will not do anything*/
	/*technically*/
		#let:/*takes in as arguments: a single expression, followed by a long expression. The short expression becomes the 1st argument in the long expression e.g.*/let (["short"..."expression"]) * long + expression;
		/*. This is then used for the new label.*/
		special cases:
			{let a = a + 2} -> {let b=a+2;let a=b;delete b}:/*If the next symbol is*/ = /*then it creates the label after the long expression. e.g.*/let a=a+1;/*Other wise it creates the label before evaluating the long expression. e.g.*/let a::{def let a.b=2;};
			{def let a:>foo()} -> {let a;#set a:>foo();def a;}:/*:> is ignored in the first short expression. This is to allow type conversions. e.g.*/let a :> float(2);/*here we make a 'float' with value '2' called 'a'. In this example float is an existing function that takes in two arguments*/
	//----
	#let set: label;//creates a new label only if it does not already exist in this block scope.
	#let set: label.property;//only creates a new property if it does not exist.
	#let set: a=b;//'let set' can be used for expressions just like and '#' operator

	#set:// is used for assigning values to existing labels.
	/*e.g*/#let: label;#set:label=2;
	/*note: because*/ #def: /*also can be used to assign values,*/#def set:/*is exactly the same as*/#def:
	/*combinind 'let' and 'set' has its own special case as shown previously.
	intended use:
	#let: a;
	#set: a=2;
	#def: a;
	#set: 1 + 2 * 4;//evaluates an expression operators are done in order exept for the assignment operators: '=', '<=>' and '<->'
	#def: label;/*inserts label into the scope's code array;*/

	/*note: at the moment:*/ #def:label; /*is syntactic sugar for:*/ $undef: label;$set: label;$def: label;//in that order
	/*the */#def/*(just like the 3:*/$undef set def:/*), applies the to the final value, meaning:*/#def: foo();/*is the same as:*/#let: bar=foo();#def: bar;
	expressions;(
		//value types:
		1,//number
		"string",//string
		label,//label,
		,//array: not used
	);
	
	infered syntax:
		/*the '#' in*/#let #set #def/*can be infered as long it is not a keyword in the assembly language. i.e in #"0xmin"; you can use*/let x=2;def x;/*instead of*/#let:x=2;#def:x;
		//e.g.
		let label=2;/*is syntactic sugar for:*/#let:label=2;
		
		//the colon ':' is only needed if the next word would be a keyword but should be parsed as a label, otherwise the ":" can infered.
		//e.g.
		let set def label;/*is the same as*/#let set def: label;/*which is also the same as*/#let set: label;#def:label;
		/*More generally: this sort of infrence applies to all parts of this programming language, and not just for*/#let set def;
		//in this document we have tried to use the more explicit syntax where possible to reduce confusion.
		
		foo()/*if a word (regex/\b\w+\b/), that is not a keyword: then it will default to*/$:foo();/*which defaults to*/$let set def: foo();
		//this is usefull for including functions calls that look the same as in most C-like programming languages
};
starter line:{
	void;{//OUT_OF_DATE
		does not add this line of code to the parent scope_object;
		usefull for mutating arrays without leaving a trace;
		note: it is pointless to use '$' and '@' type code on void lines as they cannot be found in the assembly/hidden phases.
		//lets say we want an #array with 4 items and a property pointing to the last one
		example1
		let array5{
			1;
			2;
			3;
			let item4=0;//this line is included in the array //update: this is not included
			4 #def item 4;
		};//array5..length=5
		example2
		let array4{
			1;
			2;
			3;
			void let item4=0;//this line is NOT included in the array
			4 #def item 4;
		};//array4..length=4
	};
	static;{
		not supported yet; might allow running code in function scopes.
	};
	//to ensure that Macros always hault, maximum recursion and iteration must be stated.
	repeat;{
		//allows for iteration.
		repeat single_expression:lineOfCode;//Runs the line:'lineOfCode' 'expression' times.
		e.g.
		repeat 10:foo();
		/*The expression just after the 'repeat' keyword is evaluated every iteration,
			but the maximum iterations allowed can only be reduced. This is so breaking is possible
		*/
		
		//repeat can be used to generate long arrays
		e.g.
		let longArrayOf1s={repeat 100:@1;};
		
		//example of repeat.
		#def let: array={
			let i=0;
			repeat (10-(i+=1)):
				#def: i;
			;
		};/*results with the array: {1;2;3;4;5;6}*/

		inferance;
			the colon ":" is not needed but can be used in some cases to stop the statement and the expression from merging.
			e.g.
			repeat 10: (1+1);//colon is needed here for clearness
			repeat 10 jump +3;//colon is not needed here
	};
	recur;{
		recur//Allows for the use of recursion.
		recur expression:lineOfCode;
		//note: Recursion is only allowed by using the recur statement. This is to prevent it from being turing complete
		example1{
			let foo(){
				recur 10: foo();//
			};
		}
		example2{
			let foo(){
				recur 10 #foo()...foo();//the 'recur 10' applies to the rest of the line of code after it so both 'foo()'s will be called ~10 times
			};
		}
		by default every line of code is the same as
		repeat 1 recur 1:...doStuff;
	}
};
import;{
	//import opens a file and runs it in the current scope
	//use form
	import lib "libraryFile.0xmin";//imports a standard library. aka the include folder
	import this "subFile.0xmin";//imports relative to the current file
	import main "projectFile.0xmin";//import relative to the first file.
	import "file.0xmin";//default setting: 'import "";' ==> 'import this "";' 
};
...;{
	...//injects parts of a label into the current scope's label (scope.label)
	...let: {let a,b,c;};...let object;...labelsof;//properties (namespace)
	...set: {1;2;3;};...set array;...codeof;//code (array)
	...def: (){1;2;3};...def function;...run;//runs code in scope. Can act the same as 'import'.
	//these can be combined;
	... let set def: label;
	//default
	... label; /*is the same as*/ ...let set def: label;
};
delete;{
	removes properties from an object.
	delete;//delete all labels in block scope
	delete label;//deletes label from 
	intended use:{
		#let:bar;
		#def:bar;
		move=>bar;
		delete bar;
		//ensures that 'bar' cannot be used beyond this point
	}
};
virtual;{
	code inside a virtual line acts like normal code with a few differences that affects the $ and @ phase;
	assembly inside virtual is not included in the final binary file. At the end of the virtual line, the cpu state is reset to how it was before the line;
	allows for running code in different places;
	used for struct pointers;
	e.g.:{
		let SomeStructure(){
			def let char2;
			"ab";
			def let intA;
			1;
			def let intB;
			4;
		};
		let pointer=SomeStructure=();
		virtual def pointer;
		def let someCode{//some code with the same structure as 
			"a";"b";
			1;2;
		};
		//We want 'pointer' and it's properties to have the same cpuStates as 'someCode'
		//without using 'virtual' we could use ..compile() and 
	};
};
//design notes:
//function code is imutable
//cpuState checking
{//e.g.
	$move=>0xmin;
	jump -> 2;//throws a cpuState error as move is not the same on lines 2 and 4
	move +2; //move => move+2;
	null;
}
{!jump -> 2;
	//can use '@: !command;' to ignore state checking
	//can use '!jump' or '!move'
	//'!command;' can be used for variables/constants e.g. can be used (in the 0xmin-emulator) to store return addresses in assembly function calls
	{//example of use
		$jump=> a;
		$jump->b;//state check a->b
		$jump=> 0;
		!jump a->b;
	};
	{//e.g. without '!'
		$move=>0xmin;
		jump -> 2;//The state checker throws an error Error: 'cpuState miss-match'.
		move +2; //move => move+2;
		null;
	};
	{//e.g. with '!' command
		$move=>0xmin;
		!jump -> 2;//ignores state checking and compiles as normal 'jump -> 2'
		move +2; //move => move+2;
		null;
	};
	{//the '!' command can also be used with the 'move' command so it doesn't change the cpuState.
		//e.g.
		$move=>0xmin;
		jump -> 2;
		!move +2;//doesn't change the move pointer so does not throw an error.
		null;
	};
	{//In practice the '!' modifyer is normally used to store commands as a variables, as it can do this without changing cpuState
		//e.g.
		jump 2;
		def let jump10Lines = {!jump 10};
		move=>jump10Lines;get;
		move=>2;set;
		null;//:jump command used here
	}
};
$set:foo->bar;//'->', aka the `to` operator, returns 'bar - foo'.
$set:move=>label;//'=>', aka the `set to` operator, is similar to '->' exept it sets the memory location of  foo to bar, at ($) compile time
move 2;/*is the same as:*/move=>move 2;
move=>move 2;/*is the same as:*/move->move 2;$set:move=>move 2;
move->move 2;//does not change

code blocks;{
	a codeBlock is made using curly brackets;
	The global scope is similar to a inbuilt code block;
	e.g. { ...doStuff; } //
	It contains a list of assembly instructions for the assignment ('$') and assembly ('@') phases of compilation;
	when parsed in the metacode phase:
		It is turned into a list of numbers (aka 0 code), assembly code (aka @ code), functions (aka # code),and compiler code(aka $ code).
	Code blocks can be named. This can be useful for referenceing a block within itself, while keeping it self contained.
	e.g.
	{	
		{:block;
			{
				let block.b=2;
			};
			jump b;
		};
	};
	This naming syntax can also be useful for making loops
	e.g.
	{
		#def:{:blockName;//note that blocks are not assigned memory locations by default. 
			...doStuff;
			jump->blockName;//without the '#def' this would through an $error.
		};
	};
	Using named blocks without #def can be usefull for making multi-dimentional arrays. 
	e.g.
	{
		let matrix={
			{1;0;0};
			{0;1;0};
			{0;0;1}
		};
		let twoMatrixies={
			matrix;
			matrix
		};
	};
};
function blocks;{
	//function is made by a pair of normal brackets '()' followed by an optional function type =,=>,<=,<-,-> followed by curly brackets '{}'. the normal brackets contain a list of parameters.
	//All parameters and special function variables, like return and this, are stored in a scope inbetween the function instance and the parent scope of the function.
	//e.g.
		let Foo = #(a,b)={a;b};
		
		//Here we make a 'Foo' class. In this context the '=' symbol is what makes it a class.
		//It is not important here but this function returns an array with 2 items in it.
		//The '#' stops the compiler from doing 'Foo=()'.
		//We can also do:
	//e.g.
		let Foo(a,b)={a;b};
		//For more consise syntax; This 2nd example is slightly different than the first one in what it does.
	//e.g.
		let foo(a,b){a;b};

	//by default functions return the code block.
	//this can be changed by assigning a value to the inbuilt 'return' label.

	//note:
		#let a = #(){};
		//is exactly the same as
		#let a;#let a[0] = #(){};
	//When you call an object (aka a label), all the functions and objects inside the array part are called.
	//each function uses it's own parameters but they all share the same arguments, return value and function instance object.
	//e.g.
		let bar = {(a){a};(b,c){b;c}};
		def bar(1,2);
		//gives the same result as
		let bar = {(a,b){a;a;b}};
		bar(1,2);
		//gives the same result as
		let bar = {{{(a){a}}};(b,c){b;c}};
		def bar(1,2);
	
	//function variables
	#(){
		scope;//macro only
		return;
		arguments;//the list of arguments provided, as well as containing a namespace for the aguments.
		constructor;//is the original function;
		this;//same as this in javascript, except if the function is called without a parent (i.e. 'foo()' instead of 'bar.foo()') then then it returns the var scope where the function was origionally made.
		//If the function type is a class then this returns the new function instance.
		caller;

	}
};
single_expressions;{
	expressions have the form:
	+!~ (long_expression) .a.b()()[4]..length()<:a<:b;
	single argument operators are included in expressions as well as indexing and function calls.
	datatypes;{
		label;{
			casting: ¬x ;
		}
		string;{
			casting: (""...x) ;
			casting_decimalNumber: (""...+x);
		}
		number;{
			casting: +x or !x;
			note that booleans have the number datatype so doing !!x will cast a truthy value to 1 and a falsy value to 0;
			!!label returns 1 if the label exists;
			!!+label returns 1 if the labels number value is not 0;
		}
		array;{
			casting: can not cast to array;
			array is a poorly supported type.
			It is mainly used in: debugger object..labels;
		}
	}
	internal properties;{
		Every label has internal properties;
		Accessing them calls an inbuilt javascript function;
		Some internal properties return inbuilt functions that are bonded to the label;
		full list:
		label..length;//returns a number type
		label..code;
		label..splice(a,b,c);//takes in 1 indexes, how many to remove, and an array label object. e.g. a..splice(1,2,{1;2;3});
		label..array;
		label..labels;//returns list of all the properties in an object (ignoring symbol properties)
		label..compile;//returns a MachineCode object, converted into a label. 
		label..seal;
		label..freeze;//returns a key that can be used to unfreeze the label. a frozen label's properties, number and code etc... cannot be changed. note that it only freezes 1 layer deep.
		label..this;//returns the label itself. '..this' is usefull when used like javascript's `this`. e.g. 'let obj{let addBar(){let ..this.bar=2;}}'
		label..return;//returns an inbuil label that is defaultly defined at the end of the parent label. e.g. def let block{jump->block..return;...doStuff;}
		label..proto;//if label does not contain a property, then the compiler looks for the property in label..proto
		label..super;//similar to proto except looked for first when finding a property
		label..constructor;//Returns the class '()={}' (if any) that was used to construct this label.
		label..prototype;//used in class calls i.e. 'class=()' as 'class..prototype'. 'class=()..proto == class..prototype'
		label..supertype;//similar to 'label..prototype' but for supertypes
		label..defs;//returns an array of all the places where
		label..indexOf(item);//similar to indexOf in javascript
		label..asNumber;//converts to number and returns a number type
		label..state;//returns the label's CpuState (from the start of the label). the ..state contains it's own properties.
		label..state.move;//the data pointer's state. This property was disigned for 0xmin assembly but can be used in any assembly
		label..state.jump;//the instruction pointer's state.
		label..state.ram;//the memory location. ..ram is not as usefull. It is easier to use 'jump->label' instead of 'jump->label..state.ram'
		label..flat;//returns a 1D array,can be used to get a list of all the objects in a graph, can also be used to get all the source-code of a function
	};
};
long_expressions;{
	pipeLine;{#;
		':>' operator
		e.g.
		let foo(a,b,c){
			;
		};
		let a,b,c;
		a:>b:>foo(c);
		special case:
			as described in the #let section, if the pipeline just after the first symbol in a let statement then it will be p
			e.g.
			#let a:>foo() is parsed at #let a;#set a:>foo();
		intended uses:
			//foo1:(a,b)->x; foo2:(x,c)->y
			foo1(a,b):>c:>foo2();
			{let a:>Vector3(3,4,5);}
		examples
			let foo,bar,baz,a;
			1;
				#foo() <: a:>bar();
				//same as
				#foo()<:(a:>bar());
				//same as
				#foo(bar(a))
				//this is because a:>bar() is a single expression and pipelines look for single expressions.
			2;
				#foo()<:bar()<:baz()<:a;
				//same as
				#foo()<:(bar()<:(baz()<:a));
				//same as
				#foo(bar(baz(a)));
			3;
				#foo():>bar():>baz()<:a;
				//same as
				#((foo()):>bar()):>baz()<:a
				//same as
				#baz(bar(foo()),a);
	};
	objectExtending using ::;{
		'::' operator
		#let: foo(a,b,c){
			...doStuff;
		};
		#set: foo :: (){
			...doMoreStuff;
		} :: (){
			...doEvenMoreStuff;
		} :: {
			...staticProperties;
		};
		used to concatnate objects '{}' or add a function block '(){}';
	};
	objectAssigning;{
		'{...}' and '(...)...{...}' operators
		You can assign the contense of a variable by adding an object or function expression after it.
		e.g.
		let foo(arg1,arg2)=>{...doStuff};
		let bar{...doStuff};
		At the moment they act exactly the same as the '::' operator.
		The only difference is that it cannot be done with the syntax '{}{}'. This allows for '{{}{}}' to be parsed as '{{};{}}'
	}
	brackets;{
		Can use: () {} [] aswell as #() #{} #[];
		The '#' (aka the meta) symbol can be put infront of a bracket in a long or short expression to distinguish it from function syntax
		e.g. a = (2+2) ;
		In line above we call the function 'a' as a class with the argument 4.
		e.g. a = #(2+2);
		In line above we assign 4 to the variable 'a'.
		In assembly scopes (@). the #(...) can be used to run meta code inbetween assembly lines.
		e.g. in tptasm: {
			r0 = #(4*3);//compiles to: mov r0 12
		}
	};
	{:operators;
		¬;{
			the ¬ can be used in 2 ways depending on number of argumments.
			1:
				¬x turns a value into a label with the 'symbol' value-subtype.
				This can be used to make private variables that can only be accessed by curtain parts of the code
				{:intended use;
					e.g.
					let a;
					{
						let symbol;
						#a[¬symbol]=2;
						let a.returnSymbol(){
							#return = +a[¬symbol];
						}
					};
				};]
			2: In a long expresstion, if there are statements behind the ¬, ¬ will be interpretted as the collecter operator:
				This collecter operator gets the current long expression value makes it the start of a short expression.
				It is intended to be syntactic sugar for putting '()'s around a long expresstion
				e.g.
				a + b * c ¬.d
				is the same as: ( (a + b * c).d )
				e.g.
				a + b * c ¬()
				is the same as: ( (a + b * c)() )
		};
	};
	proceedence{
		priorities{//from highest to lowest
			1: . //dot operator and function calls
			2: single argument operators including e.g. (+a) (-a) (*a) (/a) !a (¬a) (~a)
			3: :> <: //e.g. 'a:>foo()<:b' is evaluated in the order 'a,b,foo,foo(a,b)'
			4: all other operators including e.g. :: + - * / ...
			5: ¬ // the 'a+b ¬.c' operator
			6: = <=> <-> <- -> <= => //the last 4 are for in 0xmin assembly
		};
		except for assignment operators (=,<=>,<->) everything has the same priority.
		e.g. a+b*c is parsed as (a+b)*c
		assignment operators are always done last, and have the same priority
		e.g. a+b=c+d=e+f is parsed as  (a) = #(b = #(c))
	}
};
compilation_settings;{
	These include the following:
		#"0xmin";
		#"tptasm";//made for the R216K computer.
		#"int";//basic number assembly language. no pointers or special assembly syntax except for "ram"
		#"table";//prints out a list of the output file, allong with the command name and source code. Is very usefull for debugging your machine code.
		#"len";
		#"code";//
		#"make file";//is true by default can use #"!make file"; if you just want to check that some code would compile.
	At the start of a '.0xmin' file you can add; all the compilation settings.
	You can put comments and white space before and between the compilation settings are fine.
	The compilation settings are parsed after the raw text file has been broken up into a syntax tree.
	This means that you can put white space, comments between the octothwarp '#', the string '""' and the semicolon ';'. Note that the semi-colon is mandatory.
	It is also parsed before the main code is.

	You can also put a "!" at the start of the string to negate the setting. e.g. #"!table"; will not print out a table
	This normally includes the assembly language and what data the compiler should print out when it is done.
};
{//un implemented future potential features
	static;{
		let foo(){
			static ..this.bar=2;
		};
		foo.bar;
		static scopes are always run exactly once.
	};
	types;{
		':' operator;
		'foo : bar' operator would enforce the restriction 'bar' onto 'foo'; //similar to typescript
		where: foo is any Value and bar is a function or just a value;
		syntacticly: foo is a long expression and bar is a expression that matches up to a '¬' or '='
		1+1:2+2 ¬ = 2; compiles to: (((1+1) : (2+2)) ¬) = 2;
		e.g.
		let label:condisions=2;//spl
		can make "type" objects
		e.g.
		let Int(){
			???//not sure how this would work yet
		};
		let foo:Int = 2;
		let bar:Int = "a";//throws error
	};
	pipeLine;{//IS_NOW_IMPLEMENTED
		':>' operator
		let foo(a,b,c){
			;
		};
		let a,b,c;
		a:>b:>foo(c);
	};
	objectExtending using ::;{
		'::' operator
		#let: foo(a,b,c){
			...doStuff;
		};
		#set: foo :: (){
			...doMoreStuff;
		} :: (){
			...doEvenMoreStuff;
		};
		This can already be done by adding an unnamed function or object at the end of a long expression,
		e.g. in 'foo(){...stuff}' '(){...stuff}' is the extension function, that adds onto the end of the 'foo' object.
		Currently '#obj{...}{...};' can be done to extend an object. This would be changed to '#obj{}::{};'
	};
	new,var,const;{
		new, var, const would be an inbuilt version of the Data object;
		{
			#let: Data()={
				#let: varList{};
				#let: constList{};
				#let: var(data){
					#set: varList{
						$def: data;
					};
				};
				#let: const(data){
					#set: constList{
						$def: data;
					};
				};
				#let: new{//:data*
					void #let: var(condision){#;
						#let: item;
						#let: isDone=0;
						repeat: (varList..length&&isDone) {
							find a block of memory that meets the condision;
						};
						return = item;
					};
					void #let: const(data){#;
						insert new.var code but with varlist
					};
				};
			}
		};
		the original documentation mentioned these 3;
		new is a type of $set;
		'var': marks a piece of code or assembly line as variable #(not constant);
		'const': marks a piece of code or assembly line as constant;
		'var' and 'const' add code onto a JS array of free code;
		'new': assigns memory locations;
		new searches through the avalable variableList or constantList and assigns the found memory location
		examples;{
			{
				@const nor;
				@const move=>10;
				@var null;
				let new var: a;
				@move=>10#const;
			};
		};
	};
};