#"0xmin";
//keywords
	void;
	static;//static is not used yet
	virtual;
	recur;
	repeat;
	import;
	delete;
	import lib;
	import this;
	import main;
	...let;
	...set;
	...def;
	...labelsof;
	...codeof;
	...run;
	#let;
	#set;
	#def;
	$undef;
	$def;
	$set;
	$jump;
	$move;
	$ram;
	$alu;//unused
	@move;
	@jump;
	@set;
	@if;
	@nor;
	@red;
	@blue;
	@and;
	@or;
	@xor;
	@or input;
	@get jump -1;
	@set jump +3;
//words that can't be used for variables

	//[there are none]
//symbols
	@ $ #
	+ - * / ** % ^ & ~ ¬
	! ^^ || &&
	= <=> <->//operator
	-> <- => <=//assembly operator
	=> = -> <- //function types
	:> <: //pipeLineing/external arguments
	... //concat
	:: //extend object or function
	( ) [ ] { } //brackets
	"" '' ``; //strings
//defenite brackets
	#() #[] #{} //normal meta-expression brackets. The '#' is normally highlighted as white to indicate this.
//function delcarations
`note: can also do`#(){}`to avoid confusion with`foo = (){}` => `(foo=())#{}` or `foo = #(){}` => `foo = #((){})``
	(){}
	#(){}
	()={}//class
	#()={}//etc... can put '#' infront of a shortExpression to separate it from others
	()=>{}//arrow function
	()<={}//reverse arrow function
//function extensions for existing variables
	foo (){}
	foo::(){}
	foo ()={}
	foo::()={}//etc... can put '::' to make extention functions/object more explicit
	foo ()=>{}
	foo ()<={}
	foo ()->{}
	foo ()<-{}
//function calls
	foo()
	foo=()
	foo=>()
	foo<=()
	foo->()
	foo<-()
	foo(a,b,c,{...d},e,f)//can pass in objects/functions as arguments as well
	foo(a,b) <:c <:{...d} <:e <:f //same function call, just with some external arguments
	a:> b:> foo(c,{...d}) <:e <:f //using pipelinging operators
	foo(bar(baz)); or bar(baz):>foo()
//object declarations
	{}
	#{}
//object extensions
	obj{}
//@ / $ expressions
//number can be any of: +123,-123,*123,/123
	label;
	label +123;
	label label;
	label -> +123;
	label -> label;
	label label -> +123;
	label label -> label;
//line structure
//formal
@ $ # void virtual static://start of line
	recur: 2 //allows for this line to be run 2 times
		@ $ #//choses phase to start at.
		repeat: 3
			repeat: 4//3 * 4 = 12 iterations
				://assembly,hidden,meta phases: have to be done in that order; starts with the phase chosen previously
					jump label1 => label2//assembly phase; '=>' sets value, '->' just evaluates it.
					$undef set def://hidden/secret phase;
						label from => to
					#let set def://meta phase; '#def: x;' == '$undef def set: x;'
						label=foo({})+4
					delete label1, label2
					delete //remove all labels from this scope
					import this "fileName.0xmin"
					import lib "libraryName.0xmin"
					import main "fileName.0xmin"
					... let set def labelsof codeof run://inject code, similar to import and object extending
;
@ $ # void virtual static recur repeat//start of line
//note: ':'s,'@$#'s are optional but are recomended as a best practice.
//Phases symbols can be infered, prioritising the '@' phase over '#' where possible.
//It is highly recommended to use phase symbols for consistancy.
://':' can be used to allow keywords to be seen as variable names
//e.g.
	#let: let=2;//makes a variable called 'let';
//instead of
	#let let;//which does nothing; 

//change the default phase
	@; $; #;
{//e.g.
	#;//void #;
	let a;//#let: a;
	a=2;//#set: a = 2;
	@;//void @;
	a;//@a;
}//the default phase affects the nearest scope (weak scope).

{//basics
	//0xmin compatibillity version 3
	//aka 0xmin V3;
	0xmin 3;
	//aka ZASM
	ZASM;
	//aka 0xmin Assembly Small Macro language
	//aka 0@$#;
	0@$#;
	//0xmin is a C-like language. i.e. '//' == comment, {} == block of code
	//is more similar to javascript in terms of flexibility
	//zasm uses
	{};//everything even block scopes MUST end with a ';'.
	{1;2}//The only exeption is at the last line of code
};
0xmin;{//machine code
	//can write numbers
	0x123;
	123;
	0b1001;
	//can instead use number arguments for assembly code.
	//0xmin uses the form:
	//instuction(4bit) relativeAddress(8bit) sign(1bit)
	//e.g.
	//jump -5;//note: singed numbers are not yet supported can use 'jump -> label instead'
	//can be writen as a list of assembly parts:
	//in order: 
	@command address isNegative;
	1 5 1;//=>'jump -5;'=>[jump,5,-]
	1 5 0;//=>'jump +5;'=>[jump,5,+]
	//special charactors
	//char's
	"\p00";//set curser posision
	"\h";//hault. compiles to 'jump 0;'
	"\a";//accept input from terminal
	"\x00";//ASCII charactor
	"\u0000";//unicode charactor
	//char's compile to: 'print char'
	//strings
	"hello world";
	//compiles to
	"h";"e";"l";"l";"o";" ";"w";"o";"r";"l";"d";
};
@;{//assembly code
	{//basics:
		//commands;
		//pointer commands
			move;jump;
		//misc commands
			set;//writes the accumilator's (aka 'alu') value to the memory under the 'move' pointer
			if;//if an operation did not fail (i.e. would not of had result '0') since the last time the 'if' command was used, then do nothing this cycle; otherwise set the 'if' flag to 0 and run the 'null' command next cycle. aka: 'if' command has the structure: 'condision;if;then;else;'
			
			//special commands
				set jump +3;//writes the 'alu's value to the line 3 ahead of the 'jump' pointer.
				get jump -1;//reads the previous command to the 'alu'. Note that the '-1' is a bit missleading as if the last command was a 'jump 10' command, then it would return that 'jump 10' command even though it is not on the 'x-1'th line.
				or input;//does 'alu=alu|input' where input is the input port (keyboard) from the R216K2A terminal.
	
		//alu commands
			get;nor;red;blue;and;or;xor;
		
		//all commands (exept for the 3 special ones) use this structure
		command address sign;

		//e.g.
		jump 4 0;
		//compiles to:
		1 4 0;
		//compiles to:
		0x0041;
	};
	//can also use 'a to b' aka 'a -> b' syntax
	{
		#let: labelName;//created a variable/label called 'labelName' in the 'meta' ('#') phase;
		$def: labelName->0xmin 5;//then in the memory assignment ('$') phase it sets labelName's memory address to 5;
		//labels can be 
		jump->labelName;//jumps to labelName
		move=>labelName;//moves to labelName
		//'=>' is just like '->' execept at has changes the assosiated pointer compile time
		//so repeating using '->' :
			move->labelName; //move #(+labelName);
			move->labelName; //move #(+labelName);
		//would compile to the same result each time
		//but repeating  using '=>' :
			move=>labelName; //move #(+labelName);
			move=>labelName; //move 0;
		//
		//tip: in general, always use '->' with 'jump', and use '=>' with 'move'
		jump->labelName;move=>labelName;
	};
};
$;{
	$undef:label;
	$set:label; 
	$def:array;
};
#;{
	#let set def;//are executed in that order
	#let: label;/*creates a label. Can add this to the block scope e.g.*/ let label=0; /* or to the parent object e.g.*/ let object.label=2;
	//if a label exists it will replace it. labels can not be created through expressions like in javascript*/
	/*e.g.*/#set: object.newProperty=2;/*will not do anything*/  
	
	#let set: label;//creates a new label if it does not already exist in this scope.
	#let set: label.property;//only creates a new property if it does not exist.
	#let set: a=b;//'let set' can be used for expressions just like and '#' operator

	#set:// is used for assigning values to existing labels.
	/*e.g*/#let: label;#set:label=2;
	/*note: because*/ #def: /*also can be used to assign values,*/#def set:/*is exactly the same as*/#def:
	/*combinind 'let' and 'set' has its own special case as shown previously.
	intended use:
	#let: a;
	#set: a=2;
	#def: a;
	#set: 1 + 2 * 4;//evaluates an expression operators are done in order exept for the assignment operators: '=', '<=>' and '<->'
	#def: label;/*inserts label into the scope's code array;*/

	/*note: at the moment:*/ #def:label; /*is syntactic sugar for:*/ $undef: label;$set: label;$def: label;//in that order
	/*the */#def/*(just like the 3:*/$undef set def:/*), applies the to the final value, meaning:*/#def: foo();/*is the same as:*/#let: bar=foo();#def: bar;
	expressions;(
		//value types:
		1,//number
		"string",
		label,//label,
		,//array: not used
	);
	
	infered syntax:
		/*the '#' in*/#let #set #def/*can be infered as long it is not a keyword in the assembly language. i.e in #"0xmin"; you can use*/let x=2;def x;/*instead of*/#let:x=2;#def:x;
		//e.g.
		let label=2;/*is syntactic sugar for:*/#let:label=2;
		
		//the colon ':' is only needed if the next word is a keyword, otherwise it is infered.
		//e.g.
		let set def label;/*is the same as*/#let set def: label;/*which is also the same as*/#let set: label;#def:label;
		/*More generally: this sort of infrence applies to all parts of this programming language, and not just for*/#let set def;
		//in this document we have tried to use the more explicit syntax where possible to reduce confusion.
		
		foo()/*if a word (regex/\b\w+\b/), that is not a keyword: then it will default to*/:#:foo();/*which defaults to*/#def:foo();
		//this is usefull for including functions calls that look the same as in most C-like programming languages
};
starter line:{
	void;{//OUT_OF_DATE
		does not add this line of code to the parent scope_object;
		usefull for mutating arrays without leaving a trace;
		note: it is pointless to use '$' and '@' type code on void lines as they cannot be found in the assembly/hidden phases.
		//lets say we want an #array with 4 items and a property pointing to the last one
		example1
		let array5{
			1;
			2;
			3;
			let item4=0;//this line is included in the array //update: this is not included
			4 #def item 4;
		};//array5..length=5
		example2
		let array4{
			1;
			2;
			3;
			void let item4=0;//this line is NOT included in the array
			4 #def item 4;
		};//array4..length=4
	};
	static;{
		not supported yet; might allow running code in function scopes.
	};
	//to ensure that Macros always hault, maximum recursion and iteration must be stated.
	repeat;{
		//allows for iteration.
		repeat expression:lineOfCode;//Runs the line:'lineOfCode' 'expression' times.
		e.g.
		repeat 10:foo();
		/*The expression just after the 'repeat' keyword is evaluated every iteration,
			but the maximum iterations allowed can only be reduced. This is so breaking is possible
		*/
		
		//repeat can be used to generate long arrays
		e.g.
		let longArrayOf1s={repeat 100:@1;};
		
		//example of repeat.
		#def let: array={
			let i=0;
			repeat (10-(i+=1)):
				#def: i;
			;
		};/*results with the array: {1;2;3;4;5;6}*/
	};
	recur;{
		recur//Allows for the use of recursion.
		recur expression:lineOfCode;
		e.g.
		let foo(){
			recur 10: foo();//
		};
	}
};
import;{
	//import opens a file and runs it in the current scope
	//use form
	import lib "libraryFile.0xmin";//imports a standard library. aka the include folder
	import this "subFile.0xmin";//imports relative to the current file
	import main "projectFile.0xmin";//import relative to the first file.
	import "file.0xmin";//default setting: 'import "";' ==> 'import this "";' 
};
...;{
	...//injects parts of a label into the current scope's label (scope.label)
	...let: {let a,b,c;};...let object;...labelsof;//properties (namespace)
	...set: {1;2;3;};...set array;...codeof;//code (array)
	...def: (){1;2;3};...def function;...run;//runs code in scope. Can act the same as 'import'.
	//these can be combined;
	... let set def: label;
	//default
	... label; /*is the same as*/ ...let set def: label;
};
delete;{
	removes properties from an object.
	delete;//delete all labels in block scope
	delete label;//deletes label from 
	intended use:{
		#let:bar;
		#def:bar;
		move=>bar;
		delete bar;
		//ensures that 'bar' cannot be used beyond this point
	}
};
virtual;{
	code inside a virtual line acts like normal code with a few differences that affects the $ and @ phase;
	assembly inside virtual is not included in the final binary file. At the end of the virtual line, the cpu state is reset to how it was before the line;
	allows for running code in different places;
	used for struct pointers;
	e.g.:{
		let SomeStructure(){
			def let char2;
			"ab";
			def let intA;
			1;
			def let intB;
			4;
		};
		let pointer=SomeStructure=();
		virtual def pointer;
		def let someCode{//some code with the same structure as 
			"a";"b";
			1;2;
		};
		//We want 'pointer' and it's properties to have the same cpuStates as 'someCode'
		//without using 'virtual' we could use ..compile() and 
	};
};
//design notes:
//function code is imutable
//cpuState checking
{//e.g.
	$move=>0xmin;
	jump -> 2;//throws a cpuState error as move is not the same on lines 2 and 4
	move +2; //move => move+2;
	null;
}
{!jump -> 2;
	//can use '@: !command;' to ignore state checking
	//can use '!jump' or '!move'
	//'!command;' can be used for variables/constants e.g. can be used (in the 0xmin-emulator) to store return addresses in assembly function calls
	{//example of use
		$jump=> a;
		$jump->b;//state check a->b
		$jump=> 0;
		!jump a->b;
	};
	{//e.g. without '!'
		$move=>0xmin;
		jump -> 2;//The state checker throws an error Error: 'cpuState miss-match'.
		move +2; //move => move+2;
		null;
	};
	{//e.g. with '!' command
		$move=>0xmin;
		!jump -> 2;//ignores state checking and compiles as normal 'jump -> 2'
		move +2; //move => move+2;
		null;
	};
	{//the '!' command can also be used with the 'move' command so it doesn't change the cpuState.
		//e.g.
		$move=>0xmin;
		jump -> 2;
		!move +2;//doesn't change the move pointer so does not throw an error.
		null;
	}
	{//In practice the '!' modifyer is used to store commands as a variables, as it can do this without changing cpuState
		//e.g.
		jump 2;
		def let jump10Lines = {!jump 10};
		move=>jump10Lines;get;
		move=>2;set;
		null;//:jump command used here
	}
};
$set:foo->bar;//'->', aka the `to` operator, returns 'bar - foo'.
$set:move=>label;//'=>', aka the `set to` operator, is similar to '->' exept it sets the memory location of  foo to bar, at ($) compile time
move 2;/*is the same as:*/move=>move 2;
move=>move 2;/*is the same as:*/move->move 2;$set:move=>move 2;
move->move 2;//does not change

code blocks;{
	a codeBlock is made using curly brackets;
	e.g. { ...doStuff; } //
	It contains a list of instructions;
	when parsed in the metacode phase:
		It is turned into a list of numbers (aka 0 code), assembly code(aka @ code), functions(aka # code),and compiler code(aka $ code).
	Code blocks can be named. This can be used to make loops.
	e.g.
	{:blockName;
		jump->blockName;
	};

};
function blocks;{
	function is made by a pair of normal brackets () followed by an optional function type =,=>,<=,<-,-> folloed by a code block {}. the normal brackets contain a list of parameters.
	all parameters are stored in a scope inbetween the function instance and the parent scope of the function.
	e.g.
		let Foo = #(a,b)={a;b};
		here we make a 'Foo' class. the '=' is what makes it a class.
		we can also do:
		let Foo(a,b)={a;b};
		For more consise syntax; This 2nd example is slightly different than the first one in what it does.

	by default functions return the code block.
	this can be changed by assigning a value to the inbuilt 'return' label.

	note:
		#let a = #(){};
	is exactly the same as
		#let a;#let a[0] = #(){};

};
single_expressions;{
	expressions have the form:
	+!~ (long_expression) .a.b()()[4]..length()<:a<:b;
	single argument operators are included in expressions as well as indexing and function calls.
	datatypes;{
		label;{
			casting: ¬x ;
		}
		string;{
			casting: (""...x) ;
			casting_decimalNumber: (""...+x);
		}
		number;{
			casting: +x or !x;
			note that booleans have the number datatype so doing !!x will cast a truthy value to 1 and a falsy value to 0;
			!!label returns 1 if the label exists;
			!!+label returns 1 if the labels number value is not 0;
		}
		array;{
			casting: can not cast to array;
			array is a poorly supported type.
			It is mainly used in: debugger object..labels;
		}
	}
	internal properties;{
		Every label has internal properties;
		Accessing them calls an inbuilt javascript function;
		Some internal properties return inbuilt functions that are bonded to the label;
		full list:
		label..length;//:number
		label..code;
		label..splice(a,b,c);
		label..array;
		label..labels;
		label..compile;
		label..seal;
		label..freeze;
		label..this;
		label..return;
		label..proto;
		label..super;
		label..constructor;
		label..prototype;
		label..supertype;
		label..defs;
		label..indexOf(item);
		label..asNumber;
		label..state;
		label..state.move;
		label..state.jump;
		label..state.ram;
	};
};
long_expressions;{
	pipeLine;{#;
		':>' operator
		e.g.
		let foo(a,b,c){
			;
		};
		let a,b,c;
		a:>b:>foo(c);
		intended use:
			//foo1:(a,b)->x; foo2:(x,c)->y
			foo1(a,b):>c:>foo2();
	};
	objectExtending using ::;{
		'::' operator
		#let: foo(a,b,c){
			...doStuff;
		};
		#set: foo :: (){
			...doMoreStuff;
		} :: (){
			...doEvenMoreStuff;
		} :: {
			...staticProperties;
		};
		used to concatnate objects '{}' or add a function block '(){}';
	};
	brackets;{
		Can use: () {} [] aswell as #() #{} #[];
		The '#' (aka the meta) symbol can be put infront of a bracket in a long or short expression to distinguish it from function syntax
		e.g. a = (2+2) ;
		Here we call the function 'a' as a class.
		e.g. a = #(2+2);
		Here we assign 4 to the variable 'a'.
		In assembly scopes (@). the #(...) can be used to run meta code inbetween assembly lines.
		e.g. in tptasm: {
			r0 = #(4*3);//compiles to: mov r0 12
		}
	};
	{:operators;
		¬;{
			the ¬ can be used in 2 ways depending on number of argumments.
			¬x turns a value into a label with the 'symbol' value-subtype.
			This can be used to make private variables that can only be accessed by curtain parts of the code
			{:intended use;
				e.g.
				let a;
				{
					let symbol;
					#a[¬symbol]=2;
					let a.returnSymbol(){
						#return = +a[¬symbol];
					}
				};
			};
		};
	};
	proceedence{
		except for assignment operators (=,<=>,<->) everything has the same priority.
		e.g. a+b*c is parsed as (a+b)*c
		assignment operators are always done last, and have the same priority
		e.g. a+b=c+d=e+f is parsed as  (a) = #(b = #(c))
	}
}
{//un implemented future potential features
	static;{
		let foo(){
			static ..this.bar=2;
		};
		foo.bar;
		static scopes are always run exactly once.
	};
	types;{
		':' operator;
		'foo : bar' operator would enforce the restriction 'bar' onto 'foo'; //similar to typescript
		where: foo is any Value and bar is a function or just a value;
		syntacticly: foo is a long expression and bar is a expression that matches up to a '¬' or '='
		1+1:2+2 ¬ = 2; compiles to: (((1+1) : (2+2)) ¬) = 2;
		e.g.
		let label:condisions=2;//spl
		can make "type" objects
		e.g.
		let Int(){
			???//not sure how this would work yet
		};
		let foo:Int = 2;
		let bar:Int = "a";//throws error
	};
	pipeLine;{//IS_NOW_IMPLEMENTED
		':>' operator
		let foo(a,b,c){
			;
		};
		let a,b,c;
		a:>b:>foo(c);
	};
	objectExtending using ::;{
		'::' operator
		#let: foo(a,b,c){
			...doStuff;
		};
		#set: foo :: (){
			...doMoreStuff;
		} :: (){
			...doEvenMoreStuff;
		};
		This can already be done by adding an unnamed function or object at the end of a long expression,
		e.g. in 'foo(){...stuff}' '(){...stuff}' is the extension function, that adds onto the end of the 'foo' object.
		Currently '#obj{...}{...};' can be done to extend an object. This would be changed to '#obj{}::{};'
	};
	new,var,const;{
		new, var, const would be an inbuilt version of the Data object;
		{
			#let: Data()={
				#let: varList{};
				#let: constList{};
				#let: var(data){
					#set: varList{
						$def: data;
					};
				};
				#let: const(data){
					#set: constList{
						$def: data;
					};
				};
				#let: new{//:data*
					void #let: var(condision){#;
						#let: item;
						#let: isDone=0;
						repeat: (varList..length&&isDone) {
							find a block of memory that meets the condision;
						};
						return = item;
					};
					void #let: const(data){#;
						insert new.var code but with varlist
					};
				};
			}
		};
		the original documentation mentioned these 3;
		new is a type of $set;
		'var': marks a piece of code or assembly line as variable #(not constant);
		'const': marks a piece of code or assembly line as constant;
		'var' and 'const' add code onto a JS array of free code;
		'new': assigns memory locations;
		new searches through the avalable variableList or constantList and assigns the found memory location
		examples;{
			{
				@const nor;
				@const move=>10;
				@var null;
				let new var: a;
				@move=>10#const;
			};
		};
	};
};