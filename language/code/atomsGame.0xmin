/*make file;*/ 
#def let global;
#let global.return;
{
	#var red_filt()   {0x20000000;};
	#var white_filt() {0x3fffffff;};
	#var const_2{0x2;};
	#var keyCodes{
		def var isKeyDown(){0x1;};//1<<0
		def var number(){
			0x2 def var blueShift;//1<<1
			0x100000 def var redShift;//1<<20
		};
		0x200;//1<<9
	}
	#var incrementer(){
		//length=14
		#{
			#let notIn,notOut,const_2;
			#var vars{
				null def notIn;
				null def notOut;
				2 def const_2;
			};
			#move->this;
			#jump->this;
		}
		move->notIn;
		set;
		nor;//def const 2;
		set;
		blue;
		move->const_2;
		blue;
		red;
		move->notOut;
		set;
		nor;
		move->notIn;
		red;
		move->return;
	};
	#var import{
		#var random{null;};
		#var io{
			#var input1,output1,input2,output2;
			null def input1;
			null def input2;
			null def output1;
			null def output2;
		};
	};
	#var startMain{
		#move=>global;
		#var start;
		//#move->this;#jump->this;
		jump->start;
		null;
		def import.io;
	};
}
def var a{
	def startMain;
	def let board{
		#let r(){0x20000000;};
		def r();def r();def r();def r();
	};
	def let lazar{
		1 def let bitNum;//30 bits
		1 def let filtNum;//3 bits
		1 def let dir;//4 bits
	};
	def let waitForInput{
		#{#move->this;#jump->this;}//alu = output;
		#var userInput;
		#{
			#let io;
			#set io=import.io;
		}
		#let temp0;
		move->io.output1;
		set;
		move->keyCodes.isKeyDown;
		get;
		nor;
		move->temp0;//temp0=!isKeyDown;
		set;
		move->io.input1;
		get;
		nor;
		move->temp0;
		nor;//alu=isKeyDown&io.input
		if;
		nor;//if=(!(isKeyDown&io.input))
		move->this;
		if;//if(!(isKeyDown&io.input))
		jump->this;
		move->io.input1;
		get;
		move->return;//return io.input1;
		null def return;
	};
	def let vars{
		#set startMain.start=>return;
		def keyCodes;
		//def red_filt;
		//def white_filt;
		null def let temp0, waitForInput.temp0;
		null def let temp1;
	};
	def let mainLoop{//while true
		#{#move->global;#jump->this;}
		#let next{};{//call waitForInput();
			#let foo,returner;
			#set foo=waitForInput;
			move->returner;
			get;
			move->foo.return;
			set;
			move->foo;
			jump->foo;//waitForInput()
			#set next{
				#{#jump->next;#move->foo.return;}
			};
			{jump foo.return->next def returner;}
		}//alu = 6bit(input)<<1;
		{
			0x4 def let edgePartLen_const0x4;//red(1<<2) length of 2nd number
			0x8 def let numberPartLen_const0x8;//blue(1<<3) length of 1st number
			0x10 def let shift_0x10;
			null def let edgeNum;
			null def let bitNum;
			2 def let const_2;
			def let edges{{
				//alu = bitNumber
				//
				#var edge0,edge1,edge2,edge3,switch;
				{jump->edge0}
				def var vars{
				};
				#move=>switch;
				def switch{
					#{#jump=>edges;}
					null;//the condition
					jump->edge0;
					jump->edge1;
					jump->edge2;
					jump->edge3;
					#{{#def let next;#jump=>next;}}
				}
				def edge0{

				}
				def edge1{

				}
				def edge2{

				}
				def edge3{

				}
			}};
			#def next;
			//#move=>;
			def test{
				move->jump;//global;
				jump 0;
			}
			move->vars.temp0;
			set;
			{//set bitNum;
				move->keyCodes.number.redShift;
				red;

				move->edgePartLen_const0x4;
				red;
				blue;

				move->keyCodes.number.redShift;
				blue;
				move->keyCodes.number.blueShift;
				blue;
				red;
				//alu = the number
				move->bitNum;
				set;
			}
			{//set edgeNum
				move->keyCodes.number.redShift;
				red;
				blue;
				move->keyCodes.number.blueShift;
				blue;

				move->numberPartLen_const0x8;
				red;
				blue;
				
				move->keyCodes.number.blueShift;
				red;
				//alu = the number
				//move->edgeNum;
				//set;
			}
			{//set up the switch
				//alu = edgeNum
				move->const_2;
				red;
				//alu = currentEdge = move-> edgesSwitch[+edgeNum];
				move->edges.switch;
				set;
				jump->edges.switch;
			}
			move->vars.temp0;
			get;
		}
		{move->this;jump->this;}
	}
}
#def global.return;